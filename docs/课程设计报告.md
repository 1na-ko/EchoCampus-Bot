# EchoCampus-Bot 智能校园问答系统

## 课程设计报告

---

**课程名称**：数据库系统原理与应用 / 软件工程综合设计

**项目名称**：基于RAG技术的智能校园问答机器人系统

**团队名称**：EchoTech Studio（"回应"工作室）

**完成日期**：2024年

---

## 目录

- [第一章 概述](#第一章-概述)
  - [1.1 选题背景与意义](#11-选题背景与意义)
  - [1.2 小组成员及分工说明](#12-小组成员及分工说明)
  - [1.3 系统开发环境](#13-系统开发环境)
  - [1.4 技术栈说明](#14-技术栈说明)
- [第二章 需求分析](#第二章-需求分析)
  - [2.1 问题陈述与解决方案](#21-问题陈述与解决方案)
  - [2.2 系统功能需求](#22-系统功能需求)
  - [2.3 非功能需求](#23-非功能需求)
  - [2.4 数据流图与数据字典](#24-数据流图与数据字典)
  - [2.5 功能模块设计](#25-功能模块设计)
- [第三章 系统设计](#第三章-系统设计)
  - [3.1 整体架构设计](#31-整体架构设计)
  - [3.2 MVC分层设计](#32-mvc分层设计)
  - [3.3 数据库设计](#33-数据库设计)
  - [3.4 API接口设计](#34-api接口设计)
  - [3.5 AI服务集成设计](#35-ai服务集成设计)
- [第四章 数据库实施](#第四章-数据库实施)
  - [4.1 数据库建表SQL脚本](#41-数据库建表sql脚本)
  - [4.2 表间关系说明](#42-表间关系说明)
  - [4.3 视图与存储过程设计](#43-视图与存储过程设计)
  - [4.4 数据库安全性与完整性控制](#44-数据库安全性与完整性控制)
  - [4.5 数据库备份方案](#45-数据库备份方案)
- [第五章 程序功能实现](#第五章-程序功能实现)
  - [5.1 核心功能实现说明](#51-核心功能实现说明)
  - [5.2 AI功能实现细节](#52-ai功能实现细节)
  - [5.3 主要功能流程图](#53-主要功能流程图)
  - [5.4 关键技术实现代码](#54-关键技术实现代码)
  - [5.5 单元测试与集成测试](#55-单元测试与集成测试)
- [第六章 系统部署与运维](#第六章-系统部署与运维)
  - [6.1 项目打包与构建](#61-项目打包与构建)
  - [6.2 Docker容器化部署](#62-docker容器化部署)
  - [6.3 服务启动与守护](#63-服务启动与守护)
- [第七章 系统测试](#第七章-系统测试)
  - [7.1 功能测试](#71-功能测试)
  - [7.2 接口测试](#72-接口测试)
  - [7.3 性能测试](#73-性能测试)
  - [7.4 部署验证测试](#74-部署验证测试)
- [第八章 项目总结](#第八章-项目总结)
  - [8.1 项目收获与心得](#81-项目收获与心得)
  - [8.2 遇到的困难及解决方案](#82-遇到的困难及解决方案)
  - [8.3 系统亮点与创新点](#83-系统亮点与创新点)
  - [8.4 不足之处与改进方向](#84-不足之处与改进方向)

---

## 第一章 概述

### 1.1 选题背景与意义

#### 1.1.1 背景分析

随着人工智能技术的迅猛发展，特别是大语言模型（LLM）和检索增强生成（RAG）技术的成熟，智能问答系统已成为提升信息服务效率的重要手段。在校园环境中，学生和教职工经常需要查询各类校园信息，包括课程安排、校园设施、行政流程、学术资源等。传统的信息查询方式存在以下痛点：

1. **信息分散**：校园信息散布在各个网站、公告栏和部门，学生难以快速获取
2. **响应不及时**：人工咨询窗口工作时间有限，非工作时间无法获得帮助
3. **问答重复率高**：大量常见问题被反复询问，消耗人力资源
4. **信息时效性差**：静态FAQ难以及时更新，容易出现过期信息

#### 1.1.2 项目意义

本项目开发的EchoCampus-Bot智能校园问答系统，采用前沿的RAG（Retrieval-Augmented Generation）技术，将传统的信息检索与大语言模型的生成能力相结合，具有重要的理论价值和实践意义：

**技术层面**：
- 深入实践RAG架构设计，验证向量检索与LLM融合的可行性
- 探索LangChain4j框架在Java企业级应用中的集成方案
- 研究Milvus向量数据库在知识管理场景中的应用模式

**应用层面**：
- 提供7×24小时的智能问答服务，提升校园信息服务水平
- 支持多格式文档的知识库管理，便于知识的积累和更新
- 降低人工咨询成本，释放行政人员精力用于更有价值的工作

**教育层面**：
- 锻炼团队成员的全栈开发能力和AI技术应用能力
- 实践敏捷开发方法论和DevOps工程实践
- 培养团队协作和项目管理能力

#### 1.1.3 与课程设计评分标准的关联

本项目充分融合了课程设计的各项评分要求：

| 评分维度 | 权重 | 本项目对应实现 |
|---------|------|---------------|
| AI功能 | 20% | RAG智能问答、向量检索、LLM自主判断、知识库管理 |
| 云部署 | 20% | Docker容器化、多服务编排、云服务器部署 |
| 实验报告 | 20% | 本课程设计报告（含详细设计文档和代码说明） |
| 功能完整性 | 20% | 完整的前后端功能、用户系统、知识库系统 |
| 代码质量 | 20% | 分层架构、设计模式、异常处理、安全防护 |

### 1.2 小组成员及分工说明

#### 1.2.1 团队介绍

**团队名称**：EchoTech Studio（"回应"工作室）

**团队理念**：生于科技热潮，以AI之心回应学校所向，以勇立潮头争当学子回声。

#### 1.2.2 成员分工

| 成员 | 角色 | 主要职责 |
|------|------|----------|
| 成员A | 项目负责人/后端开发 | 项目整体规划、RAG核心模块开发、AI服务集成 |
| 成员B | 后端开发 | 数据库设计、MyBatis-Plus持久层、用户认证模块 |
| 成员C | 前端开发 | Vue.js前端开发、UI/UX设计、组件封装 |
| 成员D | DevOps/测试 | Docker部署、CI/CD流程、系统测试 |

### 1.3 系统开发环境

#### 1.3.1 硬件环境

**开发环境**：
- 处理器：Intel Core i7 / Apple M1 及以上
- 内存：16GB 及以上
- 存储：256GB SSD 及以上

**服务器环境**：
- 云服务商：阿里云/腾讯云/华为云
- 配置：4核8G以上，100GB SSD
- 网络：公网IP，安全组配置

#### 1.3.2 软件环境

**后端开发环境**：

| 组件 | 版本 | 说明 |
|------|------|------|
| JDK | 17 (Eclipse Temurin) | Java开发工具包 |
| Maven | 3.8+ | 项目构建和依赖管理 |
| IntelliJ IDEA | 2023.x | 主要IDE |
| Git | 2.x | 版本控制 |

**前端开发环境**：

| 组件 | 版本 | 说明 |
|------|------|------|
| Node.js | 18.x LTS | JavaScript运行时 |
| pnpm | 8.x | 包管理器 |
| VS Code | 最新版 | 前端IDE |

**数据库环境**：

| 组件 | 版本 | 说明 |
|------|------|------|
| PostgreSQL | 15-alpine | 关系型数据库 |
| Milvus | v2.3.4 | 向量数据库 |
| etcd | v3.5.5 | Milvus元数据存储 |
| MinIO | RELEASE.2023-03-20 | Milvus对象存储 |

**部署环境**：

| 组件 | 版本 | 说明 |
|------|------|------|
| Docker | 24.x | 容器化平台 |
| Docker Compose | 2.x | 多容器编排 |
| Nginx | alpine | 反向代理和静态资源服务 |

### 1.4 技术栈说明

#### 1.4.1 后端技术栈

本系统后端采用Spring Boot 3.x生态作为基础框架，结合多种企业级开发组件和AI服务：

```
┌─────────────────────────────────────────────────────────────────────┐
│                        后端技术栈架构图                               │
├─────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    Spring Boot 3.2.1                         │   │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐   │   │
│  │  │ Spring MVC  │ │Spring       │ │  Spring Security    │   │   │
│  │  │ (REST API)  │ │Validation   │ │  (JWT认证)          │   │   │
│  │  └─────────────┘ └─────────────┘ └─────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────────┐  │
│  │ MyBatis-Plus    │ │ Milvus SDK      │ │   LangChain4j       │  │
│  │ 3.5.5           │ │ 2.3.4           │ │   0.28.0            │  │
│  │ (ORM框架)       │ │ (向量数据库)     │ │   (AI编排框架)      │  │
│  └─────────────────┘ └─────────────────┘ └─────────────────────┘  │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │                      文档解析组件                             │  │
│  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐   │  │
│  │  │ PDFBox    │ │ Apache    │ │ Flexmark  │ │ Jsoup     │   │  │
│  │  │ 3.0.1     │ │ POI 5.2.5 │ │ 0.64.8    │ │ 1.17.2    │   │  │
│  │  │ (PDF)     │ │ (Office)  │ │ (Markdown)│ │ (HTML)    │   │  │
│  │  └───────────┘ └───────────┘ └───────────┘ └───────────┘   │  │
│  └─────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────────┐  │
│  │ Druid 1.2.20    │ │ Knife4j 4.4.0   │ │   Hutool 5.8.25     │  │
│  │ (连接池)        │ │ (API文档)       │ │   (工具库)          │  │
│  └─────────────────┘ └─────────────────┘ └─────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

**核心框架依赖版本表**：

| 依赖 | 版本 | 功能描述 |
|------|------|----------|
| spring-boot-starter-web | 3.2.1 | Web应用基础框架 |
| spring-boot-starter-security | 3.2.1 | 安全认证框架 |
| spring-boot-starter-mail | 3.2.1 | 邮件服务支持 |
| mybatis-plus-spring-boot3-starter | 3.5.5 | ORM持久层框架 |
| druid-spring-boot-3-starter | 1.2.20 | 数据库连接池 |
| milvus-sdk-java | 2.3.4 | Milvus向量数据库客户端 |
| langchain4j | 0.28.0 | LLM编排框架核心 |
| langchain4j-open-ai | 0.28.0 | OpenAI兼容接口支持 |
| knife4j-openapi3-jakarta-spring-boot-starter | 4.4.0 | Swagger API文档 |
| jjwt-api | 0.12.3 | JWT令牌生成与验证 |
| pdfbox | 3.0.1 | PDF文档解析 |
| poi/poi-ooxml/poi-scratchpad | 5.2.5 | Office文档解析 |
| flexmark-all | 0.64.8 | Markdown文档解析 |
| jsoup | 1.17.2 | HTML解析与清洗 |
| okhttp | 4.12.0 | HTTP客户端 |
| hutool-all | 5.8.25 | Java工具类库 |
| lombok | (Spring Boot管理) | 代码简化注解 |

#### 1.4.2 前端技术栈

前端采用Vue.js 3.x生态，结合TypeScript实现类型安全的现代前端开发：

```
┌─────────────────────────────────────────────────────────────────────┐
│                        前端技术栈架构图                               │
├─────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      Vue.js 3.4.0                            │   │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐   │   │
│  │  │ Composition │ │ TypeScript  │ │    Vite 5.0.11      │   │   │
│  │  │ API         │ │ 5.3.3       │ │    (构建工具)        │   │   │
│  │  └─────────────┘ └─────────────┘ └─────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────────┐  │
│  │ Vue Router      │ │ Pinia 2.1.7     │ │  Ant Design Vue     │  │
│  │ 4.2.5           │ │ (状态管理)      │ │  4.1.1              │  │
│  │ (路由管理)      │ │                 │ │  (UI组件库)         │  │
│  └─────────────────┘ └─────────────────┘ └─────────────────────┘  │
│                                                                     │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────────┐  │
│  │ Axios 1.6.5     │ │ marked 11.1.1   │ │ highlight.js        │  │
│  │ (HTTP请求)      │ │ (Markdown渲染)  │ │ 11.9.0 (代码高亮)   │  │
│  └─────────────────┘ └─────────────────┘ └─────────────────────┘  │
│                                                                     │
│  ┌─────────────────┐ ┌─────────────────┐                          │
│  │ @vueuse/core    │ │ dayjs 1.11.10   │                          │
│  │ 10.7.2          │ │ (日期处理)      │                          │
│  │ (Vue工具集)     │ │                 │                          │
│  └─────────────────┘ └─────────────────┘                          │
└─────────────────────────────────────────────────────────────────────┘
```

**前端依赖版本表**：

| 依赖 | 版本 | 功能描述 |
|------|------|----------|
| vue | 3.4.0 | 渐进式JavaScript框架 |
| vue-router | 4.2.5 | Vue.js官方路由管理器 |
| pinia | 2.1.7 | Vue.js状态管理库 |
| axios | 1.6.5 | 基于Promise的HTTP客户端 |
| ant-design-vue | 4.1.1 | Ant Design的Vue实现 |
| @ant-design/icons-vue | 7.0.1 | Ant Design图标库 |
| marked | 11.1.1 | Markdown解析器 |
| marked-highlight | 2.2.3 | Markdown代码高亮插件 |
| highlight.js | 11.9.0 | 语法高亮库 |
| dayjs | 1.11.10 | 轻量级日期处理库 |
| @vueuse/core | 10.7.2 | Vue Composition工具集 |

**开发依赖**：

| 依赖 | 版本 | 功能描述 |
|------|------|----------|
| typescript | 5.3.3 | TypeScript编译器 |
| vite | 5.0.11 | 下一代前端构建工具 |
| @vitejs/plugin-vue | 5.0.3 | Vite Vue插件 |
| vue-tsc | 3.2.2 | Vue TypeScript类型检查 |
| unplugin-auto-import | 0.17.3 | API自动导入 |
| unplugin-vue-components | 0.26.0 | 组件自动导入 |

#### 1.4.3 AI服务技术栈

本系统集成了多个AI服务，实现智能问答功能：

```
┌─────────────────────────────────────────────────────────────────────┐
│                        AI服务集成架构                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                    阿里云百炼平台                             │  │
│   │   ┌─────────────────────────────────────────────────────┐   │  │
│   │   │         Qwen3-Embedding (text-embedding-v3)         │   │  │
│   │   │  • 向量维度：1024                                    │   │  │
│   │   │  • API地址：dashscope.aliyuncs.com/compatible-mode  │   │  │
│   │   │  • 功能：文本向量化、语义相似度计算                   │   │  │
│   │   └─────────────────────────────────────────────────────┘   │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                       DeepSeek API                           │  │
│   │   ┌─────────────────────────────────────────────────────┐   │  │
│   │   │               deepseek-chat Model                    │   │  │
│   │   │  • 功能：自然语言生成、Tool Calling                  │   │  │
│   │   │  • API地址：api.deepseek.com/v1/chat/completions    │   │  │
│   │   │  • 特性：支持Function Call、流式输出                 │   │  │
│   │   └─────────────────────────────────────────────────────┘   │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                     Milvus向量数据库                         │  │
│   │   • 版本：v2.3.4                                             │  │
│   │   • 索引类型：IVF_FLAT                                       │  │
│   │   • 度量类型：COSINE                                         │  │
│   │   • 功能：高效向量相似度检索                                 │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 1.4.4 云平台与部署

| 组件 | 配置 | 说明 |
|------|------|------|
| 云服务商 | 阿里云/腾讯云/华为云 | ECS云服务器 |
| 服务器配置 | 4核8G, 100GB SSD | 推荐最低配置 |
| 容器平台 | Docker 24.x + Compose 2.x | 容器编排 |
| 网络配置 | 公网IP, 安全组规则 | 开放必要端口 |

---


## 第二章 需求分析

### 2.1 问题陈述与解决方案

#### 2.1.1 现状问题分析

在高校校园环境中，信息服务面临以下核心问题：

**问题一：信息孤岛现象严重**
- 校园信息分散在官方网站、教务系统、微信公众号、OA系统等多个平台
- 不同部门维护各自的信息系统，缺乏统一的信息入口
- 学生需要在多个平台之间切换查找信息，效率低下

**问题二：传统FAQ系统局限性**
- 基于关键词匹配的FAQ系统无法理解用户真实意图
- 问答内容更新滞后，难以保持信息的时效性
- 无法处理复杂的多轮对话场景

**问题三：人工咨询资源有限**
- 行政窗口服务时间固定，非工作时间无法提供帮助
- 大量重复性问题消耗人力资源
- 服务质量受个人能力和状态影响

#### 2.1.2 解决方案

本系统采用RAG（Retrieval-Augmented Generation）技术架构，结合向量检索和大语言模型，提供智能化的校园信息服务：

```
┌─────────────────────────────────────────────────────────────────────┐
│                        RAG解决方案架构                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│    用户提问                                                          │
│       │                                                             │
│       ▼                                                             │
│   ┌───────────────────────────────────────────────────────────┐    │
│   │              1. 问题向量化 (Embedding)                     │    │
│   │   使用阿里云Qwen3-Embedding将问题转换为1024维向量          │    │
│   └───────────────────────────────────────────────────────────┘    │
│       │                                                             │
│       ▼                                                             │
│   ┌───────────────────────────────────────────────────────────┐    │
│   │              2. 向量相似度检索 (Retrieval)                 │    │
│   │   在Milvus向量数据库中检索Top-K相关知识片段                │    │
│   └───────────────────────────────────────────────────────────┘    │
│       │                                                             │
│       ▼                                                             │
│   ┌───────────────────────────────────────────────────────────┐    │
│   │              3. 上下文增强 (Augmentation)                  │    │
│   │   将检索到的知识片段与用户问题组合成Prompt                 │    │
│   └───────────────────────────────────────────────────────────┘    │
│       │                                                             │
│       ▼                                                             │
│   ┌───────────────────────────────────────────────────────────┐    │
│   │              4. 答案生成 (Generation)                      │    │
│   │   DeepSeek LLM基于增强上下文生成自然语言答案               │    │
│   └───────────────────────────────────────────────────────────┘    │
│       │                                                             │
│       ▼                                                             │
│    智能回答                                                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**方案优势**：

| 传统方案 | RAG方案 | 优势说明 |
|---------|--------|----------|
| 关键词匹配 | 语义向量检索 | 理解用户真实意图 |
| 固定模板回答 | LLM动态生成 | 回答更自然流畅 |
| 人工维护问答对 | 知识库自动索引 | 降低维护成本 |
| 无法处理未见问题 | 知识泛化能力 | 处理多样化问题 |

### 2.2 系统功能需求

#### 2.2.1 核心功能需求

**F1：智能问答功能（AI核心功能）**
- F1.1 支持自然语言问答，理解用户意图
- F1.2 基于知识库进行RAG检索增强回答
- F1.3 支持流式输出，实时显示生成过程
- F1.4 AI自主判断是否需要检索知识库（Tool Calling）
- F1.5 支持多轮对话，理解上下文语境
- F1.6 展示知识来源和相似度分数

**F2：知识库管理功能**
- F2.1 支持多格式文档上传（PDF、TXT、MD、DOCX、PPT）
- F2.2 文档自动解析和智能切块
- F2.3 文档向量化存储
- F2.4 知识库分类管理
- F2.5 文档删除和重新索引

**F3：对话管理功能**
- F3.1 创建新对话会话
- F3.2 查看历史对话列表
- F3.3 查看对话详情和消息历史
- F3.4 会话重命名
- F3.5 删除对话会话

**F4：用户认证功能**
- F4.1 用户注册（邮箱验证码验证）
- F4.2 用户登录（JWT令牌认证）
- F4.3 密码重置
- F4.4 用户信息管理

**F5：系统管理功能**
- F5.1 系统配置管理（RAG参数、AI参数等）
- F5.2 系统健康检查
- F5.3 操作日志记录
- F5.4 统计数据查看

#### 2.2.2 AI功能需求详细说明

本系统的AI功能是核心亮点，具体实现包括：

**AI-1：智能检索判断（Tool Calling）**
- 系统不是简单地对每个问题都进行知识库检索
- 而是由LLM自主判断是否需要调用知识检索工具
- 对于简单问候、闲聊等场景，直接回答无需检索
- 对于涉及校园信息的问题，自动调用检索工具

**AI-2：语义向量检索**
- 使用阿里云Qwen3-Embedding模型进行文本向量化
- 向量维度1024，支持中英文混合文本
- 采用COSINE相似度度量
- 支持阈值过滤，只返回相关性高的结果

**AI-3：智能文本切块**
- 基于LangChain4j的DocumentSplitter实现
- 分层切块策略：段落 → 句子 → 字符
- 根据文档类型自适应切块参数
- 保留语义完整性，避免断句问题

**AI-4：上下文理解**
- 结合对话历史构建上下文查询
- 处理指代消解（"它"、"这个"等代词）
- 支持追问和澄清

### 2.3 非功能需求

#### 2.3.1 性能需求

| 需求项 | 指标要求 | 说明 |
|--------|----------|------|
| 响应时间 | 首字节 < 2秒 | 流式输出首字节延迟 |
| 检索延迟 | < 500ms | 向量检索响应时间 |
| 并发能力 | ≥ 50 QPS | 同时处理请求数 |
| 知识库容量 | ≥ 10000 文档 | 最大支持文档数量 |

#### 2.3.2 安全性需求

| 需求项 | 实现方式 | 说明 |
|--------|----------|------|
| 身份认证 | JWT Token | 无状态令牌认证 |
| 密码存储 | BCrypt加密 | 单向哈希存储 |
| XSS防护 | XssFilter | 请求参数过滤 |
| CSRF防护 | Cookie Token | 跨站请求伪造防护 |
| 接口限流 | RateLimiter | 防止接口滥用 |
| 提示词注入防护 | 系统提示词规则 | 防止恶意Prompt |

#### 2.3.3 可用性需求

| 需求项 | 指标要求 | 说明 |
|--------|----------|------|
| 系统可用性 | ≥ 99.9% | 月度可用时间 |
| 服务降级 | 支持 | AI服务不可用时的降级策略 |
| 健康检查 | 实现 | 服务健康状态监控 |
| 日志记录 | 完善 | 操作日志、错误日志 |

#### 2.3.4 可扩展性需求

- 支持水平扩展，可部署多实例
- 支持替换不同的Embedding模型
- 支持替换不同的LLM服务
- 支持接入更多文档格式解析器

### 2.4 数据流图与数据字典

#### 2.4.1 顶层数据流图（DFD-0）

```
                                    ┌───────────────────┐
                                    │                   │
                         ┌──────────│    外部AI服务     │──────────┐
                         │          │ (Embedding/LLM)   │          │
                         │          └───────────────────┘          │
                         │                                         │
                         │ API调用                          API响应│
                         ▼                                         │
┌───────────┐        ┌───────────────────────────────┐            │
│           │ 提问   │                               │            │
│   用户    │───────▶│     EchoCampus-Bot系统        │◀───────────┘
│           │◀───────│                               │
└───────────┘ 回答   └───────────────────────────────┘
                               │           ▲
                               │           │
                          读写数据     读写数据
                               │           │
                               ▼           │
                     ┌─────────────────────────────┐
                     │         数据存储层          │
                     │  ┌───────────┐ ┌─────────┐ │
                     │  │PostgreSQL │ │ Milvus  │ │
                     │  │ (业务数据)│ │(向量数据)│ │
                     │  └───────────┘ └─────────┘ │
                     └─────────────────────────────┘
```

#### 2.4.2 一层数据流图（DFD-1）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              EchoCampus-Bot系统                              │
│                                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │             │    │             │    │             │    │             │  │
│  │  用户认证   │    │  对话管理   │    │  知识检索   │    │  知识管理   │  │
│  │    P1       │    │    P2       │    │    P3       │    │    P4       │  │
│  │             │    │             │    │             │    │             │  │
│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘    └──────┬──────┘  │
│         │                  │                  │                  │          │
│         │                  │                  │                  │          │
│         ▼                  ▼                  ▼                  ▼          │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │                           数据访问层                                  │  │
│  │   D1:用户数据  D2:会话数据  D3:消息数据  D4:知识文档  D5:向量数据     │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 2.4.3 RAG问答流程数据流图（DFD-2）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              RAG问答子系统                                   │
│                                                                             │
│   用户问题                                                                  │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────────┐                                                           │
│  │  P3.1       │    文本                 ┌─────────────┐                   │
│  │  问题预处理 │──────────────────────▶ │  P3.2       │                   │
│  │             │                         │  问题向量化 │                   │
│  └─────────────┘                         └──────┬──────┘                   │
│                                                 │                          │
│                                            问题向量                        │
│                                                 │                          │
│                                                 ▼                          │
│  ┌─────────────┐    相关知识片段    ┌─────────────┐                       │
│  │  P3.4       │◀───────────────────│  P3.3       │                       │
│  │ Prompt构建  │                    │  向量检索   │                       │
│  │             │                    │             │                       │
│  └──────┬──────┘                    └─────────────┘                       │
│         │                                  ▲                               │
│    增强Prompt                              │                               │
│         │                             检索请求                             │
│         ▼                                  │                               │
│  ┌─────────────┐                    ┌─────────────┐                       │
│  │  P3.5       │    调用LLM        │    D5       │                       │
│  │  答案生成   │────────────▶      │  Milvus    │                       │
│  │  (DeepSeek) │                    │  向量数据  │                       │
│  └──────┬──────┘                    └─────────────┘                       │
│         │                                                                  │
│      AI回答                                                                │
│         │                                                                  │
│         ▼                                                                  │
│  ┌─────────────┐                                                          │
│  │  P3.6       │                                                          │
│  │  结果后处理 │──────────▶ 返回用户                                      │
│  │  & 存储     │                                                          │
│  └─────────────┘                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 2.4.4 数据字典

**D1：用户数据（users）**

| 字段 | 类型 | 说明 | 约束 |
|------|------|------|------|
| id | BIGSERIAL | 用户ID | 主键，自增 |
| username | VARCHAR(50) | 用户名 | 唯一，非空 |
| password | VARCHAR(255) | 密码哈希 | 非空，BCrypt加密 |
| email | VARCHAR(100) | 邮箱 | 唯一 |
| nickname | VARCHAR(50) | 昵称 | 可选 |
| role | VARCHAR(20) | 角色 | USER/ADMIN |
| status | VARCHAR(20) | 状态 | ACTIVE/INACTIVE/LOCKED |
| last_login_at | TIMESTAMP | 最后登录时间 | 可选 |
| created_at | TIMESTAMP | 创建时间 | 默认当前时间 |
| updated_at | TIMESTAMP | 更新时间 | 默认当前时间 |

**D2：对话会话数据（conversations）**

| 字段 | 类型 | 说明 | 约束 |
|------|------|------|------|
| id | BIGSERIAL | 会话ID | 主键，自增 |
| user_id | BIGINT | 用户ID | 外键→users(id) |
| title | VARCHAR(200) | 会话标题 | 非空 |
| message_count | INTEGER | 消息数量 | 默认0 |
| status | VARCHAR(20) | 状态 | ACTIVE/ARCHIVED/DELETED |
| created_at | TIMESTAMP | 创建时间 | 默认当前时间 |
| updated_at | TIMESTAMP | 更新时间 | 默认当前时间 |

**D3：消息数据（messages）**

| 字段 | 类型 | 说明 | 约束 |
|------|------|------|------|
| id | BIGSERIAL | 消息ID | 主键，自增 |
| conversation_id | BIGINT | 会话ID | 外键→conversations(id) |
| parent_message_id | BIGINT | 父消息ID | 外键→messages(id) |
| sender_type | VARCHAR(20) | 发送者类型 | USER/BOT/SYSTEM |
| content | TEXT | 消息内容 | 非空 |
| token_count | INTEGER | Token数量 | 默认0 |
| metadata | JSONB | 元数据 | 检索结果、耗时等 |
| created_at | TIMESTAMP | 创建时间 | 默认当前时间 |

**D4：知识文档数据（knowledge_docs）**

| 字段 | 类型 | 说明 | 约束 |
|------|------|------|------|
| id | BIGSERIAL | 文档ID | 主键，自增 |
| title | VARCHAR(200) | 文档标题 | 非空 |
| description | TEXT | 文档描述 | 可选 |
| file_name | VARCHAR(255) | 文件名 | 原始文件名 |
| file_path | VARCHAR(500) | 文件路径 | 服务器存储路径 |
| file_size | BIGINT | 文件大小 | 字节数 |
| file_type | VARCHAR(50) | 文件类型 | pdf/txt/md/docx/ppt等 |
| category | VARCHAR(100) | 分类 | 知识分类 |
| tags | VARCHAR(500) | 标签 | 逗号分隔 |
| status | VARCHAR(20) | 状态 | ACTIVE/INACTIVE/PROCESSING/FAILED |
| vector_count | INTEGER | 向量数量 | 默认0 |
| process_status | VARCHAR(20) | 处理状态 | PENDING/PROCESSING/COMPLETED/FAILED |
| process_message | TEXT | 处理信息 | 错误信息等 |
| last_indexed_at | TIMESTAMP | 最后索引时间 | 可选 |
| created_by | BIGINT | 创建者ID | 外键→users(id) |
| created_at | TIMESTAMP | 创建时间 | 默认当前时间 |
| updated_at | TIMESTAMP | 更新时间 | 默认当前时间 |

**D5：知识片段数据（knowledge_chunks）**

| 字段 | 类型 | 说明 | 约束 |
|------|------|------|------|
| id | BIGSERIAL | 片段ID | 主键，自增 |
| doc_id | BIGINT | 文档ID | 外键→knowledge_docs(id) |
| chunk_index | INTEGER | 片段索引 | 在文档中的位置 |
| chunk_type | VARCHAR(20) | 片段类型 | TEXT/TITLE/CODE |
| content | TEXT | 片段内容 | 非空 |
| content_hash | VARCHAR(64) | 内容哈希 | 用于去重 |
| vector_id | VARCHAR(100) | Milvus向量ID | 关联向量数据库 |
| page_number | INTEGER | 页码 | PDF页码 |
| metadata | JSONB | 元数据 | 段落标题等 |
| token_count | INTEGER | Token数量 | 默认0 |
| start_position | INTEGER | 起始位置 | 文档中字符位置 |
| end_position | INTEGER | 结束位置 | 文档中字符位置 |
| created_at | TIMESTAMP | 创建时间 | 默认当前时间 |

### 2.5 功能模块设计

#### 2.5.1 系统功能模块结构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           EchoCampus-Bot 智能校园问答系统                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │             │  │             │  │             │  │                     │ │
│  │  用户模块   │  │  对话模块   │  │  知识模块   │  │      AI核心模块     │ │
│  │             │  │             │  │             │  │                     │ │
│  ├─────────────┤  ├─────────────┤  ├─────────────┤  ├─────────────────────┤ │
│  │ • 用户注册  │  │ • 创建会话  │  │ • 文档上传  │  │ • Embedding服务     │ │
│  │ • 用户登录  │  │ • 会话列表  │  │ • 文档解析  │  │ • 向量检索服务      │ │
│  │ • 密码重置  │  │ • 消息历史  │  │ • 文本切块  │  │ • LLM对话服务       │ │
│  │ • 邮箱验证  │  │ • 会话删除  │  │ • 向量存储  │  │ • Tool Calling      │ │
│  │ • 个人信息  │  │ • 会话重命名│  │ • 分类管理  │  │ • RAG编排服务       │ │
│  │ • JWT认证   │  │ • 流式输出  │  │ • 重新索引  │  │ • 流式生成          │ │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────────────┘ │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                            系统管理模块                                  ││
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐ ││
│  │  │ 系统配置    │  │ 健康检查    │  │ 操作日志    │  │ 统计分析        │ ││
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────────┘ ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 2.5.2 AI核心模块详细设计

AI核心模块是本系统的技术亮点，采用分层设计实现复杂的RAG流程：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              AI核心模块架构                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                          EnhancedRagService                            │  │
│  │                        (增强RAG服务 - 编排层)                          │  │
│  │   • 构建上下文查询                                                      │  │
│  │   • 管理Tool调用流程                                                    │  │
│  │   • 整合检索结果与LLM响应                                              │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                    │                            │
│                           ▼                    ▼                            │
│  ┌─────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │    EnhancedLlmService       │  │      KnowledgeSearchTool            │  │
│  │    (增强LLM服务)            │  │      (知识检索工具)                  │  │
│  │   • 支持Tool Calling        │  │   • 向量检索封装                     │  │
│  │   • 流式输出处理            │  │   • 结果格式化                       │  │
│  │   • 多轮对话管理            │  │   • 相似度过滤                       │  │
│  └─────────────────────────────┘  └─────────────────────────────────────┘  │
│                 │                                     │                     │
│                 ▼                                     ▼                     │
│  ┌─────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │      DeepSeek API           │  │         EmbeddingService             │  │
│  │      (LLM服务)              │  │         (向量化服务)                 │  │
│  │   • Chat Completions        │  │   • 单文本向量化                     │  │
│  │   • Function Calling        │  │   • 批量向量化                       │  │
│  │   • Stream Response         │  │   • 重试机制                         │  │
│  └─────────────────────────────┘  └─────────────────────────────────────┘  │
│                                                       │                     │
│                                                       ▼                     │
│                                  ┌─────────────────────────────────────┐   │
│                                  │          MilvusService               │   │
│                                  │          (向量数据库服务)            │   │
│                                  │   • 集合管理                         │   │
│                                  │   • 向量插入                         │   │
│                                  │   • 相似度搜索                       │   │
│                                  │   • 向量删除                         │   │
│                                  └─────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---


## 第三章 系统设计

### 3.1 整体架构设计

#### 3.1.1 系统架构概述

本系统采用经典的前后端分离架构，结合微服务思想设计，将传统业务层与AI服务层有机整合。系统架构分为四个主要层次：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           系统整体架构图                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                          用户访问层                                  │   │
│  │   ┌─────────────────┐         ┌─────────────────────────────────┐   │   │
│  │   │   Web浏览器     │         │      移动端（未来扩展）         │   │   │
│  │   │   (Vue.js SPA)  │         │      (小程序/APP)               │   │   │
│  │   └─────────────────┘         └─────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                HTTP/HTTPS                                   │
│                                    │                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                          网关/反向代理层                            │   │
│  │                              Nginx                                   │   │
│  │          ┌──────────────────────┬──────────────────────┐           │   │
│  │          │      /api/*          │       /*              │           │   │
│  │          │    后端API代理       │    前端静态资源        │           │   │
│  │          └──────────────────────┴──────────────────────┘           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                          应用服务层                                  │   │
│  │   ┌─────────────────────────────────────────────────────────────┐   │   │
│  │   │                  Spring Boot Application                     │   │   │
│  │   │                                                              │   │   │
│  │   │   ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌──────────┐│   │   │
│  │   │   │ Controller │ │  Service   │ │   DAO      │ │  Filter  ││   │   │
│  │   │   │    层      │ │    层      │ │   层       │ │  /拦截器  ││   │   │
│  │   │   └────────────┘ └────────────┘ └────────────┘ └──────────┘│   │   │
│  │   │                                                              │   │   │
│  │   │   ┌─────────────────────────────────────────────────────┐   │   │   │
│  │   │   │              AI Service Layer                        │   │   │   │
│  │   │   │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │   │   │
│  │   │   │  │Embedding│ │   LLM   │ │  RAG    │ │ Milvus  │   │   │   │   │
│  │   │   │  │ Service │ │ Service │ │ Service │ │ Service │   │   │   │   │
│  │   │   │  └─────────┘ └─────────┘ └─────────┘ └─────────┘   │   │   │   │
│  │   │   └─────────────────────────────────────────────────────┘   │   │   │
│  │   └─────────────────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                          │                    │                             │
│  ┌───────────────────────┴────────────────────┴─────────────────────────┐  │
│  │                          数据存储层                                   │  │
│  │   ┌────────────────────┐      ┌────────────────────────────────────┐ │  │
│  │   │    PostgreSQL      │      │           Milvus集群               │ │  │
│  │   │    关系型数据库     │      │  ┌────────┐ ┌────────┐ ┌────────┐│ │  │
│  │   │   • 用户数据        │      │  │ Milvus │ │  etcd  │ │ MinIO  ││ │  │
│  │   │   • 会话数据        │      │  │Standalone│ │元数据  │ │对象存储││ │  │
│  │   │   • 知识元数据      │      │  └────────┘ └────────┘ └────────┘│ │  │
│  │   │   • 系统配置        │      │           向量数据库               │ │  │
│  │   └────────────────────┘      └────────────────────────────────────┘ │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │                          外部服务层                                   │  │
│  │   ┌────────────────────────┐      ┌────────────────────────────┐    │  │
│  │   │    阿里云百炼平台      │      │       DeepSeek API         │    │  │
│  │   │   Qwen3-Embedding      │      │      deepseek-chat         │    │  │
│  │   │   (文本向量化服务)     │      │      (大语言模型服务)       │    │  │
│  │   └────────────────────────┘      └────────────────────────────┘    │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 3.1.2 技术选型依据

**Spring Boot 3.2.1 选型理由**：
- 原生支持Jakarta EE 9+，与新一代Java生态兼容
- 内置Tomcat服务器，开发部署便捷
- 丰富的Starter生态，快速集成各类组件
- 强大的自动配置机制，减少样板代码

**MyBatis-Plus 3.5.5 选型理由**：
- 对MyBatis的增强，保留灵活性的同时提升开发效率
- 内置代码生成器、分页插件、逻辑删除支持
- Lambda表达式构建查询，类型安全
- 与Spring Boot 3完美兼容

**Milvus 2.3.4 选型理由**：
- 专为向量相似度搜索设计的分布式数据库
- 支持多种索引类型（IVF_FLAT、HNSW等）
- 支持过滤查询，结合标量和向量搜索
- 提供完善的Java SDK

**LangChain4j 0.28.0 选型理由**：
- Java版LangChain，为Java开发者提供AI编排能力
- 内置文档分割器，支持语义保持的文本切块
- 统一的AI服务抽象，易于切换模型提供商
- 支持Tool Calling等高级特性

### 3.2 MVC分层设计

#### 3.2.1 分层架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Spring Boot MVC分层架构                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │                       Controller Layer (控制层)                        │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐  │ │
│  │  │    Chat     │ │  Knowledge  │ │    User     │ │    System       │  │ │
│  │  │ Controller  │ │ Controller  │ │ Controller  │ │   Controller    │  │ │
│  │  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘ └────────┬────────┘  │ │
│  │         │               │               │                  │           │ │
│  │         └───────────────┴───────────────┴──────────────────┘           │ │
│  │                                   │                                     │ │
│  │                            @RequestMapping                              │ │
│  │                            @Valid @RequestBody                          │ │
│  │                            Result<T>统一响应                            │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                      │                                      │
│                              依赖注入 @Autowired                            │
│                                      │                                      │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │                        Service Layer (服务层)                          │ │
│  │                                                                         │ │
│  │  ┌──────────────────────────────────────────────────────────────────┐  │ │
│  │  │                     业务服务 (Business Service)                   │  │ │
│  │  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────────────┐ │  │ │
│  │  │  │   Chat    │ │ Knowledge │ │   User    │ │ VerificationCode  │ │  │ │
│  │  │  │  Service  │ │  Service  │ │  Service  │ │     Service       │ │  │ │
│  │  │  └───────────┘ └───────────┘ └───────────┘ └───────────────────┘ │  │ │
│  │  └──────────────────────────────────────────────────────────────────┘  │ │
│  │                                                                         │ │
│  │  ┌──────────────────────────────────────────────────────────────────┐  │ │
│  │  │                       AI服务 (AI Service)                         │  │ │
│  │  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────────────┐ │  │ │
│  │  │  │ Enhanced  │ │ Enhanced  │ │ Embedding │ │     Milvus        │ │  │ │
│  │  │  │RAG Service│ │LLM Service│ │  Service  │ │     Service       │ │  │ │
│  │  │  └───────────┘ └───────────┘ └───────────┘ └───────────────────┘ │  │ │
│  │  └──────────────────────────────────────────────────────────────────┘  │ │
│  │                                                                         │ │
│  │  ┌──────────────────────────────────────────────────────────────────┐  │ │
│  │  │                    辅助服务 (Support Service)                     │  │ │
│  │  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────────────┐ │  │ │
│  │  │  │ TextChunk │ │ Document  │ │   Email   │ │   DataCleanup     │ │  │ │
│  │  │  │  Service  │ │Process Svc│ │  Service  │ │     Service       │ │  │ │
│  │  │  └───────────┘ └───────────┘ └───────────┘ └───────────────────┘ │  │ │
│  │  └──────────────────────────────────────────────────────────────────┘  │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                      │                                      │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │                         DAO Layer (数据访问层)                         │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐│ │
│  │  │                     MyBatis-Plus Mapper                            ││ │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────────┐ ││ │
│  │  │  │  User   │ │Conversa-│ │ Message │ │Knowledge│ │ Knowledge   │ ││ │
│  │  │  │ Mapper  │ │tion Map │ │ Mapper  │ │Doc Map  │ │ Chunk Map   │ ││ │
│  │  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────────┘ ││ │
│  │  │                                                                    ││ │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────────────────────┐ ││ │
│  │  │  │ Search  │ │ System  │ │Knowledge│ │   EmailVerification     │ ││ │
│  │  │  │Log Map  │ │Config M │ │Category │ │       Code Mapper       │ ││ │
│  │  │  └─────────┘ └─────────┘ └─────────┘ └─────────────────────────┘ ││ │
│  │  └───────────────────────────────────────────────────────────────────┘│ │
│  │                            extends BaseMapper<T>                       │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                      │                                      │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │                        Entity Layer (实体层)                           │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐│ │
│  │  │  @Data @TableName                                                  ││ │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────────┐ ││ │
│  │  │  │  User   │ │Conversa-│ │ Message │ │Knowledge│ │ Knowledge   │ ││ │
│  │  │  │         │ │  tion   │ │         │ │   Doc   │ │   Chunk     │ ││ │
│  │  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────────┘ ││ │
│  │  └───────────────────────────────────────────────────────────────────┘│ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 3.2.2 各层职责说明

**Controller层职责**：
- 接收HTTP请求，进行参数校验（@Valid）
- 调用Service层处理业务逻辑
- 封装统一响应格式（Result<T>）
- 处理SSE流式响应（SseEmitter）

**Service层职责**：
- 实现具体业务逻辑
- 事务管理（@Transactional）
- 调用多个DAO进行数据操作
- 调用外部AI服务

**DAO层职责**：
- 数据库CRUD操作
- 继承MyBatis-Plus的BaseMapper
- 自定义复杂查询方法

**Entity层职责**：
- 定义数据库表映射实体
- 使用Lombok简化代码
- MyBatis-Plus注解配置

#### 3.2.3 后端包结构设计

```
com.echocampus.bot/
├── EchoCampusBotApplication.java          # Spring Boot启动类
├── annotation/                            # 自定义注解
│   └── RateLimit.java                     # 限流注解
├── common/                                # 通用类
│   ├── Result.java                        # 统一响应封装
│   ├── ResultCode.java                    # 响应状态码枚举
│   └── exception/                         # 自定义异常
│       └── BusinessException.java         # 业务异常类
├── config/                                # 配置类
│   ├── AiServiceConfig.java               # AI服务配置（Embedding/LLM参数）
│   ├── MilvusConfig.java                  # Milvus连接配置
│   ├── MyBatisPlusConfig.java             # MyBatis-Plus分页配置
│   ├── SecurityConfig.java                # Spring Security配置
│   ├── WebConfig.java                     # CORS跨域配置
│   ├── RateLimitConfig.java               # 限流配置
│   ├── ThreadPoolConfig.java              # 线程池配置
│   └── SwaggerConfig.java                 # Knife4j文档配置
├── controller/                            # 控制器
│   ├── ChatController.java                # 聊天接口
│   ├── KnowledgeController.java           # 知识库接口
│   ├── UserController.java                # 用户接口
│   ├── SystemController.java              # 系统管理接口
│   └── HealthController.java              # 健康检查接口
├── dto/                                   # 数据传输对象
│   ├── request/                           # 请求DTO
│   │   ├── ChatRequest.java               # 聊天请求
│   │   ├── LoginRequest.java              # 登录请求
│   │   └── RegisterRequest.java           # 注册请求
│   └── response/                          # 响应DTO
│       ├── ChatResponse.java              # 聊天响应
│       ├── StreamChatResponse.java        # 流式聊天响应
│       └── UserResponse.java              # 用户响应
├── entity/                                # 数据库实体
│   ├── User.java                          # 用户实体
│   ├── Conversation.java                  # 会话实体
│   ├── Message.java                       # 消息实体
│   ├── KnowledgeDoc.java                  # 知识文档实体
│   ├── KnowledgeChunk.java                # 知识片段实体
│   ├── KnowledgeCategory.java             # 知识分类实体
│   ├── SystemConfig.java                  # 系统配置实体
│   ├── SearchLog.java                     # 搜索日志实体
│   └── EmailVerificationCode.java         # 邮箱验证码实体
├── filter/                                # 过滤器
│   ├── JwtAuthenticationFilter.java       # JWT认证过滤器
│   └── XssFilter.java                     # XSS防护过滤器
├── interceptor/                           # 拦截器
│   └── LoggingInterceptor.java            # 日志拦截器
├── mapper/                                # MyBatis Mapper
│   ├── UserMapper.java
│   ├── ConversationMapper.java
│   ├── MessageMapper.java
│   ├── KnowledgeDocMapper.java
│   ├── KnowledgeChunkMapper.java
│   ├── KnowledgeCategoryMapper.java
│   ├── SystemConfigMapper.java
│   ├── SearchLogMapper.java
│   └── EmailVerificationCodeMapper.java
├── parser/                                # 文档解析器
│   ├── DocumentParser.java                # 解析器接口
│   ├── DocumentParserFactory.java         # 解析器工厂
│   ├── dto/
│   │   └── ParseResult.java               # 解析结果DTO
│   ├── exception/
│   │   └── DocumentParseException.java    # 解析异常
│   └── impl/                              # 解析器实现
│       ├── PdfDocumentParser.java         # PDF解析器
│       ├── TxtDocumentParser.java         # TXT解析器
│       ├── MarkdownDocumentParser.java    # Markdown解析器
│       ├── DocxDocumentParser.java        # DOCX解析器
│       ├── DocDocumentParser.java         # DOC解析器
│       ├── PptDocumentParser.java         # PPT/PPTX解析器
│       └── ExcelDocumentParser.java       # Excel解析器
├── service/                               # 服务接口
│   ├── ChatService.java
│   ├── KnowledgeService.java
│   ├── UserService.java
│   ├── EmbeddingService.java
│   ├── MilvusService.java
│   ├── LlmService.java
│   ├── EnhancedLlmService.java
│   ├── RagService.java
│   ├── EnhancedRagService.java
│   ├── TextChunkService.java
│   ├── DocumentProcessService.java
│   ├── DocumentProgressService.java
│   ├── EmailService.java
│   ├── VerificationCodeService.java
│   ├── DataCleanupService.java
│   ├── impl/                              # 服务实现
│   │   ├── ChatServiceImpl.java
│   │   ├── KnowledgeServiceImpl.java
│   │   ├── UserServiceImpl.java
│   │   ├── EmbeddingServiceImpl.java
│   │   ├── MilvusServiceImpl.java
│   │   ├── LlmServiceImpl.java
│   │   ├── EnhancedLlmServiceImpl.java
│   │   ├── RagServiceImpl.java
│   │   ├── EnhancedRagServiceImpl.java
│   │   ├── TextChunkServiceImpl.java
│   │   ├── DocumentProcessServiceImpl.java
│   │   ├── DocumentProgressServiceImpl.java
│   │   ├── EmailServiceImpl.java
│   │   ├── VerificationCodeServiceImpl.java
│   │   └── DataCleanupServiceImpl.java
│   └── tool/                              # AI工具
│       └── KnowledgeSearchTool.java       # 知识检索工具
├── task/                                  # 定时任务
│   └── ScheduledTasks.java                # 定时清理任务
└── utils/                                 # 工具类
    ├── JwtUtil.java                       # JWT工具
    ├── FileUtil.java                      # 文件工具
    └── JsonUtil.java                      # JSON工具
```

### 3.3 数据库设计

#### 3.3.1 概念结构设计（E-R图）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              E-R图 (实体关系图)                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                              ┌─────────────┐                               │
│                              │    User     │                               │
│                              │   (用户)    │                               │
│                              └──────┬──────┘                               │
│                                     │                                       │
│                         ┌───────────┼───────────┐                          │
│                         │  1:N      │  1:N      │  1:N                     │
│                         ▼           ▼           ▼                          │
│              ┌─────────────┐ ┌─────────────┐ ┌─────────────┐              │
│              │Conversation │ │ Knowledge   │ │   Email     │              │
│              │   (会话)    │ │    Doc      │ │ Verification│              │
│              └──────┬──────┘ │  (知识文档) │ │    Code     │              │
│                     │        └──────┬──────┘ └─────────────┘              │
│                     │               │                                       │
│                   1:N             1:N                                       │
│                     │               │                                       │
│                     ▼               ▼                                       │
│              ┌─────────────┐ ┌─────────────┐                              │
│              │   Message   │ │  Knowledge  │                              │
│              │   (消息)    │ │   Chunk     │                              │
│              └─────────────┘ │  (知识片段) │                              │
│                              └─────────────┘                               │
│                                     │                                       │
│                                   1:1                                       │
│                                     │                                       │
│                                     ▼                                       │
│                              ┌─────────────┐                               │
│                              │   Milvus    │                               │
│                              │   Vector    │                               │
│                              │  (向量数据)  │                               │
│                              └─────────────┘                               │
│                                                                             │
│   ┌─────────────┐        ┌─────────────┐        ┌─────────────┐           │
│   │  Knowledge  │        │   System    │        │  Search     │           │
│   │  Category   │        │   Config    │        │    Log      │           │
│   │  (知识分类) │        │  (系统配置) │        │  (搜索日志) │           │
│   └─────────────┘        └─────────────┘        └─────────────┘           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 3.3.2 逻辑结构设计（关系模式）

**用户关系模式**：
```
User(id, username, password, email, nickname, role, status, last_login_at, created_at, updated_at)
主键：id
候选键：username, email
```

**对话会话关系模式**：
```
Conversation(id, user_id, title, message_count, status, created_at, updated_at)
主键：id
外键：user_id → User(id)
```

**消息关系模式**：
```
Message(id, conversation_id, parent_message_id, sender_type, content, token_count, metadata, created_at)
主键：id
外键：conversation_id → Conversation(id)
      parent_message_id → Message(id)
```

**知识文档关系模式**：
```
KnowledgeDoc(id, title, description, file_name, file_path, file_size, file_type, category, tags, status, vector_count, process_status, process_message, last_indexed_at, created_by, created_at, updated_at)
主键：id
外键：created_by → User(id)
```

**知识片段关系模式**：
```
KnowledgeChunk(id, doc_id, chunk_index, chunk_type, content, content_hash, vector_id, page_number, metadata, token_count, start_position, end_position, created_at)
主键：id
外键：doc_id → KnowledgeDoc(id)
```

#### 3.3.3 物理结构设计（表结构）

表结构详细设计见第四章"数据库实施"部分。

### 3.4 API接口设计

#### 3.4.1 RESTful API设计规范

本系统遵循RESTful API设计原则，采用以下规范：

**URL规范**：
- 基础路径：`/api/v1`（通过Spring配置server.servlet.context-path实现）
- 资源名称使用名词复数形式
- 使用连字符（-）分隔复合词

**HTTP方法语义**：

| 方法 | 语义 | 示例 |
|------|------|------|
| GET | 获取资源 | GET /v1/chat/conversations |
| POST | 创建资源 | POST /v1/chat/message |
| PUT | 更新资源 | PUT /v1/chat/conversations/{id} |
| DELETE | 删除资源 | DELETE /v1/chat/conversations/{id} |

**统一响应格式**：

```json
{
    "code": 200,
    "message": "success",
    "data": {
        // 响应数据
    }
}
```

**错误响应格式**：

```json
{
    "code": 400,
    "message": "参数校验失败",
    "data": null
}
```

#### 3.4.2 核心API接口清单

**认证接口**：

| 接口 | 方法 | 路径 | 说明 |
|------|------|------|------|
| 用户注册 | POST | /v1/auth/register | 邮箱验证码注册 |
| 用户登录 | POST | /v1/auth/login | JWT令牌登录 |
| 发送验证码 | POST | /v1/auth/send-code | 发送邮箱验证码 |
| 重置密码 | POST | /v1/auth/reset-password | 通过验证码重置 |

**聊天接口**：

| 接口 | 方法 | 路径 | 说明 |
|------|------|------|------|
| 发送消息 | POST | /v1/chat/message | 发送消息获取回复 |
| 发送消息(流式) | POST | /v1/chat/message/stream | SSE流式输出 |
| 获取会话列表 | GET | /v1/chat/conversations | 分页获取会话 |
| 获取会话消息 | GET | /v1/chat/conversations/{id}/messages | 获取历史消息 |
| 创建会话 | POST | /v1/chat/conversations | 创建新会话 |
| 删除会话 | DELETE | /v1/chat/conversations/{id} | 删除会话 |
| 更新会话标题 | PUT | /v1/chat/conversations/{id} | 重命名会话 |

**知识库接口**：

| 接口 | 方法 | 路径 | 说明 |
|------|------|------|------|
| 上传文档 | POST | /v1/knowledge/docs | 上传知识文档 |
| 获取文档列表 | GET | /v1/knowledge/docs | 分页查询文档 |
| 获取文档详情 | GET | /v1/knowledge/docs/{id} | 获取单个文档 |
| 删除文档 | DELETE | /v1/knowledge/docs/{id} | 删除文档和向量 |
| 重新索引 | POST | /v1/knowledge/docs/{id}/reindex | 重建文档向量 |
| 获取分类列表 | GET | /v1/knowledge/categories | 获取知识分类 |

**系统接口**：

| 接口 | 方法 | 路径 | 说明 |
|------|------|------|------|
| 健康检查 | GET | /v1/health | 服务健康状态 |
| 获取系统配置 | GET | /v1/system/config | 获取配置项 |
| 更新系统配置 | PUT | /v1/system/config | 更新配置项 |
| 获取系统统计 | GET | /v1/system/stats | 系统统计信息 |

#### 3.4.3 流式响应接口设计

流式聊天接口采用Server-Sent Events (SSE)技术，实现实时推送：

**请求**：
```http
POST /v1/chat/message/stream
Content-Type: application/json
Authorization: Bearer {jwt_token}

{
    "conversationId": 123,  // 可选，为空创建新会话
    "message": "上应大有哪些食堂？"
}
```

**响应（SSE事件流）**：
```
event: status
data: {"type":"STATUS","conversationId":123,"content":"正在智能分析您的问题..."}

event: status
data: {"type":"STATUS","conversationId":123,"content":"🔍 正在检索：上应大食堂"}

event: sources
data: {"type":"SOURCES","conversationId":123,"sources":[{"docId":1,"title":"校园设施介绍","chunkId":5,"content":"...","similarity":0.92}]}

event: status
data: {"type":"STATUS","conversationId":123,"content":"💡 正在生成回答..."}

event: content
data: {"type":"CONTENT","conversationId":123,"content":"上海应用技术"}

event: content
data: {"type":"CONTENT","conversationId":123,"content":"大学主要有以下食堂："}

event: done
data: {"type":"DONE","conversationId":123,"messageId":456}
```

### 3.5 AI服务集成设计

#### 3.5.1 AI接口选型与评估

**Embedding服务选型**：

| 服务商 | 模型 | 维度 | 优势 | 劣势 |
|--------|------|------|------|------|
| 阿里云百炼 | text-embedding-v3 | 1024 | 中文优化、价格低、稳定 | 需要阿里云账号 |
| OpenAI | text-embedding-3-small | 1536 | 效果好 | 价格高、网络问题 |
| 智谱AI | embedding-2 | 1024 | 国内访问快 | 免费额度有限 |

**选型结论**：选择阿里云百炼平台的Qwen3-Embedding（text-embedding-v3），原因：
- 1024维向量在效果和存储开销间取得平衡
- 对中文文本有针对性优化
- 价格实惠，适合学习项目
- API兼容OpenAI格式，便于迁移

**LLM服务选型**：

| 服务商 | 模型 | 特点 | 优势 | 劣势 |
|--------|------|------|------|------|
| DeepSeek | deepseek-chat | 128K上下文 | 性价比极高、支持Tool Calling | 知名度较低 |
| OpenAI | gpt-3.5-turbo | 16K上下文 | 生态成熟 | 价格高、需要代理 |
| 阿里云 | qwen-plus | 32K上下文 | 国内访问快 | 价格适中 |

**选型结论**：选择DeepSeek API（deepseek-chat），原因：
- 支持Function Calling（Tool Calling），满足AI自主判断需求
- 价格极具竞争力
- 支持流式输出
- API兼容OpenAI格式

#### 3.5.2 请求/响应数据结构设计

**Embedding API请求**：

```java
// EmbeddingServiceImpl.java
Map<String, Object> requestBody = new HashMap<>();
requestBody.put("model", "text-embedding-v3");
requestBody.put("input", texts);  // List<String> 待向量化的文本列表
```

**Embedding API响应**：

```json
{
    "data": [
        {
            "embedding": [0.123, -0.456, ...],  // 1024维浮点数组
            "index": 0
        }
    ],
    "usage": {
        "prompt_tokens": 100,
        "total_tokens": 100
    }
}
```

**LLM API请求（带Tool Calling）**：

```java
// EnhancedLlmServiceImpl.java
Map<String, Object> requestBody = new HashMap<>();
requestBody.put("model", "deepseek-chat");
requestBody.put("messages", messages);
requestBody.put("max_tokens", 2000);
requestBody.put("temperature", 0.7);
requestBody.put("stream", true);  // 流式输出
requestBody.put("tools", toolDefs);  // 工具定义
requestBody.put("tool_choice", "auto");  // 让AI自主决定是否调用工具
```

**Tool定义格式**：

```json
{
    "type": "function",
    "function": {
        "name": "searchKnowledge",
        "description": "在校园知识库中搜索相关信息",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "要搜索的问题或关键词"
                }
            },
            "required": ["query"]
        }
    }
}
```

#### 3.5.3 错误处理与重试机制

**Embedding服务错误处理**：

```java
// EmbeddingServiceImpl.java
private List<float[]> doEmbedRequest(List<String> texts) {
    int retries = 0;
    while (retries < config.getMaxRetries()) {  // 最大重试3次
        try {
            // 发送请求...
            if (!response.isSuccessful()) {
                log.error("Embedding API请求失败: code={}", response.code());
                retries++;
                continue;
            }
            // 解析响应...
            return embeddings;
        } catch (IOException e) {
            log.error("Embedding API请求异常: {}", e.getMessage());
            retries++;
            if (retries < config.getMaxRetries()) {
                Thread.sleep(1000 * retries);  // 指数退避
            }
        }
    }
    // 返回零向量作为降级方案
    return emptyEmbeddings;
}
```

**LLM服务错误处理**：

```java
// EnhancedLlmServiceImpl.java
try {
    Response response = httpClient.newCall(request).execute();
    if (!response.isSuccessful()) {
        String errorBody = response.body() != null ? response.body().string() : "无响应体";
        log.error("LLM API请求失败: code={}, body={}", response.code(), errorBody);
        return "抱歉，AI服务暂时不可用，请稍后再试。";
    }
    // 处理响应...
} catch (IOException e) {
    log.error("LLM服务异常: {}", e.getMessage());
    return "抱歉，AI服务出现异常：" + e.getMessage();
}
```

#### 3.5.4 AI配置参数设计

系统通过`AiServiceConfig`类集中管理AI服务配置：

```java
@Data
@Configuration
@ConfigurationProperties(prefix = "ai")
public class AiServiceConfig {
    
    // Embedding配置
    private EmbeddingConfig embedding = new EmbeddingConfig();
    
    // LLM配置
    private LlmConfig llm = new LlmConfig();
    
    @Data
    public static class EmbeddingConfig {
        private String apiKey;
        private String apiUrl = "https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings";
        private String model = "text-embedding-v3";
        private Integer dimension = 1024;
        private Integer batchSize = 10;
        private Integer maxRetries = 3;
    }
    
    @Data
    public static class LlmConfig {
        private String apiKey;
        private String apiUrl = "https://api.deepseek.com/v1/chat/completions";
        private String model = "deepseek-chat";
        private Integer maxTokens = 2000;
        private Double temperature = 0.7;
        private Integer timeout = 60;
    }
}
```

**配置文件示例（application.yml）**：

```yaml
ai:
  embedding:
    api-key: ${ALIYUN_API_KEY}
    api-url: https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
    model: text-embedding-v3
    dimension: 1024
    batch-size: 10
    max-retries: 3
  llm:
    api-key: ${DEEPSEEK_API_KEY}
    api-url: https://api.deepseek.com/v1/chat/completions
    model: deepseek-chat
    max-tokens: 2000
    temperature: 0.7
    timeout: 60
```

---


## 第四章 数据库实施

### 4.1 数据库建表SQL脚本

本系统采用PostgreSQL 15作为关系型数据库。以下是完整的建表脚本，包含主键、外键、约束和索引定义。

#### 4.1.1 用户表（users）

```sql
-- 用户表
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100) UNIQUE,
    nickname VARCHAR(50),
    role VARCHAR(20) DEFAULT 'USER',        -- USER: 普通用户, ADMIN: 管理员
    status VARCHAR(20) DEFAULT 'ACTIVE',    -- ACTIVE: 活跃, INACTIVE: 停用, LOCKED: 锁定
    last_login_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status ON users(status);

-- 约束说明
-- 1. id: 自增主键，唯一标识用户
-- 2. username: 用户名，唯一约束，非空
-- 3. password: BCrypt加密存储，非空
-- 4. email: 邮箱，唯一约束，用于验证码发送
-- 5. role: 角色枚举，默认USER
-- 6. status: 状态枚举，默认ACTIVE

-- 插入默认管理员 (密码: admin123，BCrypt加密)
INSERT INTO users (username, password, email, nickname, role, status) VALUES 
('admin', '$2a$10$7JB720yubVSZFyL9BbGfQe1C6PQRJZG6fGS.0FdJMR5N1h6W5GPTG', 
 'admin@example.com', 'Admin', 'ADMIN', 'ACTIVE');
```

#### 4.1.2 邮箱验证码表（email_verification_codes）

```sql
-- 邮箱验证码表
CREATE TABLE email_verification_codes (
    id BIGSERIAL PRIMARY KEY,
    email VARCHAR(100) NOT NULL,
    code VARCHAR(10) NOT NULL,
    type VARCHAR(20) NOT NULL,              -- REGISTER: 注册, RESET_PASSWORD: 重置密码
    expired_at TIMESTAMP NOT NULL,
    used BOOLEAN DEFAULT FALSE,
    used_at TIMESTAMP,
    ip_address VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_email_verification_codes_email ON email_verification_codes(email);
CREATE INDEX idx_email_verification_codes_type ON email_verification_codes(type);
CREATE INDEX idx_email_verification_codes_expired_at ON email_verification_codes(expired_at);
CREATE INDEX idx_email_verification_codes_used ON email_verification_codes(used);

-- 复合索引：用于查询未使用的有效验证码
CREATE INDEX idx_email_verification_codes_query ON email_verification_codes(email, type, used, expired_at DESC);

-- 表注释
COMMENT ON TABLE email_verification_codes IS '邮箱验证码表';
COMMENT ON COLUMN email_verification_codes.email IS '邮箱地址';
COMMENT ON COLUMN email_verification_codes.code IS '6位验证码';
COMMENT ON COLUMN email_verification_codes.type IS '验证码类型';
COMMENT ON COLUMN email_verification_codes.expired_at IS '过期时间';
COMMENT ON COLUMN email_verification_codes.used IS '是否已使用';
```

#### 4.1.3 对话会话表（conversations）

```sql
-- 对话会话表
CREATE TABLE conversations (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,
    message_count INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'ACTIVE',    -- ACTIVE: 活跃, ARCHIVED: 归档, DELETED: 已删除
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_conversations_user_id ON conversations(user_id);
CREATE INDEX idx_conversations_status ON conversations(status);
CREATE INDEX idx_conversations_updated_at ON conversations(updated_at DESC);

-- 约束说明
-- 1. user_id: 外键关联users表，级联删除
-- 2. message_count: 消息计数，通过触发器自动更新
```

#### 4.1.4 对话消息表（messages）

```sql
-- 对话消息表
CREATE TABLE messages (
    id BIGSERIAL PRIMARY KEY,
    conversation_id BIGINT NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    parent_message_id BIGINT REFERENCES messages(id) ON DELETE SET NULL,
    sender_type VARCHAR(20) NOT NULL,       -- USER: 用户, BOT: 机器人, SYSTEM: 系统
    content TEXT NOT NULL,
    token_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}',            -- 存储检索来源、响应时间等元数据
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_sender_type ON messages(sender_type);
CREATE INDEX idx_messages_created_at ON messages(created_at);
CREATE INDEX idx_messages_metadata ON messages USING gin(metadata);

-- 触发器：消息插入后自动更新会话统计
CREATE OR REPLACE FUNCTION update_conversation_stats()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE conversations 
    SET message_count = message_count + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = NEW.conversation_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_conversation_stats
    AFTER INSERT ON messages
    FOR EACH ROW
    EXECUTE FUNCTION update_conversation_stats();
```

#### 4.1.5 知识文档表（knowledge_docs）

```sql
-- 知识文档表
CREATE TABLE knowledge_docs (
    id BIGSERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    file_name VARCHAR(255),
    file_path VARCHAR(500),
    file_size BIGINT,
    file_type VARCHAR(50),                  -- pdf, txt, md, docx, doc, ppt, pptx
    category VARCHAR(100),
    tags VARCHAR(500),                      -- 逗号分隔的标签
    status VARCHAR(20) DEFAULT 'ACTIVE',    -- ACTIVE, INACTIVE, PROCESSING, FAILED
    vector_count INTEGER DEFAULT 0,
    process_status VARCHAR(20) DEFAULT 'PENDING',  -- PENDING, PROCESSING, COMPLETED, FAILED
    process_message TEXT,
    last_indexed_at TIMESTAMP,
    created_by BIGINT REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_knowledge_docs_category ON knowledge_docs(category);
CREATE INDEX idx_knowledge_docs_status ON knowledge_docs(status);
CREATE INDEX idx_knowledge_docs_file_type ON knowledge_docs(file_type);
CREATE INDEX idx_knowledge_docs_created_by ON knowledge_docs(created_by);
CREATE INDEX idx_knowledge_docs_created_at ON knowledge_docs(created_at DESC);

-- 全文搜索索引
CREATE INDEX idx_knowledge_docs_title_search ON knowledge_docs USING gin(to_tsvector('english', title));
CREATE INDEX idx_knowledge_docs_description_search ON knowledge_docs USING gin(to_tsvector('english', description));
```

#### 4.1.6 知识片段表（knowledge_chunks）

```sql
-- 知识片段表
CREATE TABLE knowledge_chunks (
    id BIGSERIAL PRIMARY KEY,
    doc_id BIGINT NOT NULL REFERENCES knowledge_docs(id) ON DELETE CASCADE,
    chunk_index INTEGER NOT NULL,           -- 片段在文档中的位置索引
    chunk_type VARCHAR(20) DEFAULT 'TEXT',  -- TEXT, TITLE, CODE
    content TEXT NOT NULL,
    content_hash VARCHAR(64),               -- SHA-256哈希，用于去重
    vector_id VARCHAR(100),                 -- Milvus中的向量ID
    page_number INTEGER,                    -- PDF页码
    metadata JSONB DEFAULT '{}',
    token_count INTEGER DEFAULT 0,
    start_position INTEGER,                 -- 在原文中的起始位置
    end_position INTEGER,                   -- 在原文中的结束位置
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_knowledge_chunks_doc_id ON knowledge_chunks(doc_id);
CREATE INDEX idx_knowledge_chunks_vector_id ON knowledge_chunks(vector_id);
CREATE INDEX idx_knowledge_chunks_content_hash ON knowledge_chunks(content_hash);
CREATE INDEX idx_knowledge_chunks_metadata ON knowledge_chunks USING gin(metadata);

-- 全文搜索索引
CREATE INDEX idx_knowledge_chunks_content_search ON knowledge_chunks USING gin(to_tsvector('english', content));

-- 触发器：片段数量变化时更新文档统计
CREATE OR REPLACE FUNCTION update_doc_vector_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE knowledge_docs 
        SET vector_count = vector_count + 1 
        WHERE id = NEW.doc_id;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE knowledge_docs 
        SET vector_count = vector_count - 1 
        WHERE id = OLD.doc_id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_doc_vector_count
    AFTER INSERT OR DELETE ON knowledge_chunks
    FOR EACH ROW
    EXECUTE FUNCTION update_doc_vector_count();
```

#### 4.1.7 系统配置表（system_config）

```sql
-- 系统配置表
CREATE TABLE system_config (
    id BIGSERIAL PRIMARY KEY,
    config_key VARCHAR(100) UNIQUE NOT NULL,
    config_value TEXT,
    config_type VARCHAR(20) DEFAULT 'STRING',  -- STRING, NUMBER, BOOLEAN, JSON
    description VARCHAR(500),
    is_editable BOOLEAN DEFAULT TRUE,
    updated_by BIGINT REFERENCES users(id),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 初始化默认配置
INSERT INTO system_config (config_key, config_value, config_type, description) VALUES 
-- RAG相关配置
('rag.top_k', '5', 'NUMBER', 'RAG检索返回的最相关文档数量'),
('rag.temperature', '0.7', 'NUMBER', 'AI生成答案的温度参数(0.0-1.0)'),
('rag.similarity_threshold', '0.6', 'NUMBER', '相似度阈值，低于此值的结果将被过滤'),

-- Milvus相关配置
('milvus.collection_name', 'echocampus_knowledge', 'STRING', 'Milvus向量集合名称'),
('milvus.dimension', '1024', 'NUMBER', '向量维度(Qwen3-Embedding)'),
('milvus.metric_type', 'COSINE', 'STRING', '相似度度量类型'),
('milvus.index_type', 'IVF_FLAT', 'STRING', '索引类型'),
('milvus.nprobe', '10', 'NUMBER', '搜索的簇数量'),

-- Embedding相关配置
('embedding.model', 'text-embedding-v3', 'STRING', 'Embedding模型'),
('embedding.batch_size', '10', 'NUMBER', 'Embedding批量处理大小'),
('embedding.max_retries', '3', 'NUMBER', 'API最大重试次数'),

-- LLM相关配置
('llm.model', 'deepseek-chat', 'STRING', 'LLM模型'),
('llm.max_tokens', '2000', 'NUMBER', 'LLM生成最大token数'),
('llm.timeout', '60', 'NUMBER', 'LLM API超时时间(秒)'),

-- 文件上传配置
('file.upload.max_size', '10485760', 'NUMBER', '文件上传最大大小(10MB)'),
('file.allowed_types', 'pdf,txt,md,docx,doc,ppt,pptx', 'STRING', '允许上传的文件类型'),

-- 文本切块配置
('chunking.strategy', 'recursive', 'STRING', '文本切块策略'),
('chunking.max_size', '500', 'NUMBER', '文本切块最大字符数'),
('chunking.overlap_size', '50', 'NUMBER', '文本切块重叠字符数'),

-- 系统配置
('system.name', 'EchoCampus-Bot', 'STRING', '系统名称'),
('system.description', '基于RAG技术的智能校园问答系统', 'STRING', '系统描述');
```

#### 4.1.8 检索日志表（search_logs）

```sql
-- 检索日志表
CREATE TABLE search_logs (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(id),
    conversation_id BIGINT REFERENCES conversations(id),
    query TEXT NOT NULL,
    query_vector_id VARCHAR(100),
    retrieved_chunks JSONB,                 -- 检索到的片段信息
    response_time_ms INTEGER,               -- 响应时间(毫秒)
    answer_tokens INTEGER,
    status VARCHAR(20) DEFAULT 'SUCCESS',   -- SUCCESS, FAILED
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_search_logs_user_id ON search_logs(user_id);
CREATE INDEX idx_search_logs_conversation_id ON search_logs(conversation_id);
CREATE INDEX idx_search_logs_created_at ON search_logs(created_at);
CREATE INDEX idx_search_logs_retrieved_chunks ON search_logs USING gin(retrieved_chunks);
```

#### 4.1.9 知识分类表（knowledge_categories）

```sql
-- 知识分类表
CREATE TABLE knowledge_categories (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    parent_id BIGINT REFERENCES knowledge_categories(id),
    sort_order INTEGER DEFAULT 0,
    doc_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_knowledge_categories_parent_id ON knowledge_categories(parent_id);
CREATE INDEX idx_knowledge_categories_sort_order ON knowledge_categories(sort_order);
```

### 4.2 表间关系说明

#### 4.2.1 实体关系图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           数据库表关系图                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                              users                                          │
│                         ┌─────────────┐                                    │
│                         │     PK      │                                    │
│                         │     id      │                                    │
│                         └──────┬──────┘                                    │
│                   ┌────────────┼────────────┬──────────────┐               │
│                   │            │            │              │               │
│                   ▼            ▼            ▼              ▼               │
│          ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │
│          │conversations│ │knowledge_   │ │email_verif..│ │search_logs  │  │
│          │   FK:user_id│ │docs         │ │             │ │  FK:user_id │  │
│          └──────┬──────┘ │FK:created_by│ └─────────────┘ └─────────────┘  │
│                 │        └──────┬──────┘                                   │
│                 │               │                                          │
│                 ▼               ▼                                          │
│          ┌─────────────┐ ┌─────────────┐                                  │
│          │  messages   │ │knowledge_   │                                  │
│          │FK:conv_id   │ │chunks       │                                  │
│          │FK:parent_id │ │FK:doc_id    │                                  │
│          └─────────────┘ └─────────────┘                                  │
│                                 │                                          │
│                            ┌────┴────┐                                     │
│                            │ Milvus  │                                     │
│                            │ Vector  │                                     │
│                            │(1:1关联)│                                     │
│                            └─────────┘                                     │
│                                                                             │
│   图例：                                                                    │
│   ───▶ 外键关系                                                            │
│   PK: 主键                                                                 │
│   FK: 外键                                                                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 4.2.2 外键约束说明

| 表名 | 外键字段 | 引用表.字段 | 删除策略 | 说明 |
|------|----------|-------------|----------|------|
| conversations | user_id | users.id | CASCADE | 删除用户时级联删除会话 |
| messages | conversation_id | conversations.id | CASCADE | 删除会话时级联删除消息 |
| messages | parent_message_id | messages.id | SET NULL | 删除父消息时置空 |
| knowledge_docs | created_by | users.id | SET NULL | 删除用户时保留文档 |
| knowledge_chunks | doc_id | knowledge_docs.id | CASCADE | 删除文档时级联删除片段 |
| search_logs | user_id | users.id | SET NULL | 删除用户时保留日志 |
| search_logs | conversation_id | conversations.id | SET NULL | 删除会话时保留日志 |
| knowledge_categories | parent_id | knowledge_categories.id | SET NULL | 自关联 |

### 4.3 视图与存储过程设计

#### 4.3.1 知识库统计视图

```sql
-- 知识库统计视图
CREATE VIEW knowledge_stats AS
SELECT 
    kc.id AS category_id,
    kc.name AS category_name,
    COUNT(kd.id) AS doc_count,
    SUM(COALESCE(kd.vector_count, 0)) AS total_vectors,
    MAX(kd.updated_at) AS last_updated
FROM knowledge_categories kc
LEFT JOIN knowledge_docs kd ON kc.name = kd.category
WHERE kd.status = 'ACTIVE' OR kd.status IS NULL
GROUP BY kc.id, kc.name
ORDER BY kc.sort_order;

-- 使用示例
-- SELECT * FROM knowledge_stats;
```

#### 4.3.2 用户活跃度统计视图

```sql
-- 用户活跃度统计视图
CREATE VIEW user_activity_stats AS
SELECT 
    u.id AS user_id,
    u.username,
    u.nickname,
    COUNT(DISTINCT c.id) AS conversation_count,
    COUNT(DISTINCT m.id) AS message_count,
    MAX(m.created_at) AS last_activity
FROM users u
LEFT JOIN conversations c ON u.id = c.user_id AND c.status = 'ACTIVE'
LEFT JOIN messages m ON c.id = m.conversation_id
WHERE u.status = 'ACTIVE'
GROUP BY u.id, u.username, u.nickname;

-- 使用示例
-- SELECT * FROM user_activity_stats ORDER BY message_count DESC LIMIT 10;
```

#### 4.3.3 触发器函数

系统使用触发器自动维护统计数据：

```sql
-- 1. 消息插入触发器（已在4.1.4定义）
-- 功能：插入消息时自动更新会话的message_count和updated_at

-- 2. 知识片段统计触发器（已在4.1.6定义）
-- 功能：插入/删除知识片段时自动更新文档的vector_count
```

### 4.4 数据库安全性与完整性控制

#### 4.4.1 数据完整性约束

**实体完整性**：
- 所有表都定义了主键（BIGSERIAL自增）
- 主键自动创建唯一索引

**参照完整性**：
- 外键约束确保引用关系有效
- ON DELETE策略根据业务需求选择CASCADE或SET NULL

**域完整性**：
- 字段类型约束（VARCHAR长度、INTEGER等）
- NOT NULL约束确保必填字段
- DEFAULT值设置合理默认

**用户自定义完整性**：
- UNIQUE约束（username、email）
- CHECK约束（可选，如status枚举值检查）

#### 4.4.2 数据库用户权限设计

```sql
-- 创建应用用户
CREATE USER echocampus_app WITH PASSWORD 'secure_password';

-- 授予表操作权限
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO echocampus_app;

-- 授予序列使用权限
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO echocampus_app;

-- 撤销删除表权限（防止误操作）
REVOKE DROP ON ALL TABLES IN SCHEMA public FROM echocampus_app;
```

#### 4.4.3 敏感数据保护

**密码存储**：
- 使用BCrypt算法加密存储
- 加盐处理防止彩虹表攻击

```java
// UserServiceImpl.java
@Override
public void register(RegisterRequest request) {
    // BCrypt加密密码
    String encodedPassword = passwordEncoder.encode(request.getPassword());
    user.setPassword(encodedPassword);
}
```

**API密钥管理**：
- 不存储在数据库中
- 通过环境变量配置
- 运行时从配置加载

### 4.5 数据库备份方案

#### 4.5.1 备份策略

| 备份类型 | 频率 | 保留周期 | 说明 |
|----------|------|----------|------|
| 全量备份 | 每日 | 7天 | pg_dump完整备份 |
| 增量备份 | 每小时 | 24小时 | WAL归档 |
| 事务日志 | 实时 | 7天 | 用于时间点恢复 |

#### 4.5.2 备份脚本示例

```bash
#!/bin/bash
# backup.sh - PostgreSQL数据库备份脚本

# 配置
DB_NAME="echocampus_bot"
DB_USER="postgres"
BACKUP_DIR="/backup/postgres"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/${DB_NAME}_${DATE}.sql.gz"

# 创建备份目录
mkdir -p ${BACKUP_DIR}

# 执行备份
PGPASSWORD=${DB_PASSWORD} pg_dump -h localhost -U ${DB_USER} ${DB_NAME} | gzip > ${BACKUP_FILE}

# 清理7天前的备份
find ${BACKUP_DIR} -name "*.sql.gz" -mtime +7 -delete

# 记录日志
echo "[$(date)] Backup completed: ${BACKUP_FILE}" >> ${BACKUP_DIR}/backup.log
```

#### 4.5.3 Docker环境备份

在Docker Compose环境中，可以通过以下方式执行备份：

```bash
# 执行容器内备份
docker exec echocampus-postgres pg_dump -U postgres echocampus_bot > backup.sql

# 或者使用docker-compose exec
docker-compose exec postgres pg_dump -U ${POSTGRES_USER} ${POSTGRES_DB} > backup.sql
```

---


## 第五章 程序功能实现

### 5.1 核心功能实现说明

#### 5.1.1 用户认证模块

用户认证采用JWT（JSON Web Token）无状态认证方案，结合Spring Security实现。

**认证流程**：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              JWT认证流程                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│    ┌──────────┐    1.登录请求    ┌──────────────┐                          │
│    │  客户端  │─────────────────▶│ UserController│                          │
│    │          │                   │   /auth/login │                          │
│    └──────────┘                   └───────┬───────┘                          │
│         ▲                                 │                                  │
│         │                                 ▼                                  │
│         │                        ┌──────────────┐                           │
│         │                        │ UserService  │                           │
│         │                        │ 验证用户名密码│                           │
│         │                        └───────┬───────┘                           │
│         │                                │                                  │
│         │   2.返回JWT Token              ▼                                  │
│         │◀──────────────────────┌──────────────┐                           │
│         │                        │   JwtUtil    │                           │
│         │                        │  生成Token   │                           │
│    ┌────┴─────┐                  └──────────────┘                           │
│    │  客户端  │                                                             │
│    │存储Token │                                                             │
│    └────┬─────┘                                                             │
│         │                                                                    │
│         │   3.携带Token请求API                                              │
│         ▼                                                                    │
│    ┌──────────────────────────────────────────────────────────┐            │
│    │               JwtAuthenticationFilter                     │            │
│    │  1. 从Header提取Token                                     │            │
│    │  2. 验证Token有效性                                       │            │
│    │  3. 解析用户信息                                          │            │
│    │  4. 设置SecurityContext                                   │            │
│    └──────────────────────────────────────────────────────────┘            │
│         │                                                                    │
│         ▼                                                                    │
│    ┌──────────────┐                                                        │
│    │  Controller  │                                                        │
│    │  处理业务    │                                                        │
│    └──────────────┘                                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**JWT工具类核心实现**：

```java
@Component
public class JwtUtil {
    
    @Value("${jwt.secret}")
    private String secretKey;
    
    @Value("${jwt.expiration:86400000}")
    private long expiration;  // 默认24小时
    
    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));
    }
    
    // 生成Token
    public String generateToken(Long userId, String username) {
        return Jwts.builder()
                .claim("userId", userId)
                .claim("username", username)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSigningKey())
                .compact();
    }
    
    // 解析Token
    public Claims parseToken(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
    
    // 验证Token
    public boolean validateToken(String token) {
        try {
            parseToken(token);
            return true;
        } catch (JwtException e) {
            return false;
        }
    }
}
```

#### 5.1.2 对话管理模块

对话管理支持创建会话、发送消息、查看历史等功能。

**ChatServiceImpl核心实现**：

```java
@Service
@RequiredArgsConstructor
public class ChatServiceImpl implements ChatService {
    
    private final ConversationMapper conversationMapper;
    private final MessageMapper messageMapper;
    private final EnhancedRagService enhancedRagService;
    
    @Override
    @Transactional
    public ChatResponse sendMessage(Long userId, ChatRequest request) {
        // 1. 获取或创建会话
        Conversation conversation = getOrCreateConversation(userId, request);
        
        // 2. 保存用户消息
        Message userMessage = new Message();
        userMessage.setConversationId(conversation.getId());
        userMessage.setSenderType("USER");
        userMessage.setContent(request.getMessage());
        messageMapper.insert(userMessage);
        
        // 3. 获取历史消息用于上下文
        List<Message> history = messageMapper.selectRecentByConversationId(
                conversation.getId(), 10);
        
        // 4. 调用RAG服务获取回答
        RagService.RagResponse ragResponse = enhancedRagService.answerWithAutoRetrieval(
                request.getMessage(), history, userId, conversation.getId());
        
        // 5. 保存AI回复
        Message botMessage = new Message();
        botMessage.setConversationId(conversation.getId());
        botMessage.setSenderType("BOT");
        botMessage.setContent(ragResponse.getAnswer());
        botMessage.setMetadata(buildMetadata(ragResponse));
        messageMapper.insert(botMessage);
        
        // 6. 构建响应
        return ChatResponse.builder()
                .conversationId(conversation.getId())
                .messageId(botMessage.getId())
                .answer(ragResponse.getAnswer())
                .sources(ragResponse.getSources())
                .responseTime(ragResponse.getResponseTime())
                .build();
    }
}
```

#### 5.1.3 知识库管理模块

知识库管理实现文档的完整生命周期管理。

**文档处理流程**：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           文档处理流程图                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│    ┌──────────────┐                                                        │
│    │   文档上传   │                                                        │
│    │ (MultipartFile)│                                                       │
│    └───────┬──────┘                                                        │
│            │                                                                │
│            ▼                                                                │
│    ┌──────────────┐     ┌──────────────┐                                  │
│    │   文件校验   │────▶│   保存文件   │                                  │
│    │(类型、大小)  │     │  (本地存储)  │                                  │
│    └──────────────┘     └───────┬──────┘                                  │
│                                 │                                          │
│                                 ▼                                          │
│    ┌──────────────────────────────────────────────────────────────────┐   │
│    │                    异步处理流程 (@Async)                          │   │
│    │                                                                    │   │
│    │    ┌──────────────┐     ┌──────────────┐     ┌──────────────┐   │   │
│    │    │ 文档解析器   │────▶│  文本切块    │────▶│  向量化      │   │   │
│    │    │ (Factory)    │     │(LangChain4j) │     │(Embedding)   │   │   │
│    │    └──────────────┘     └──────────────┘     └───────┬──────┘   │   │
│    │                                                       │          │   │
│    │                                                       ▼          │   │
│    │    ┌──────────────┐     ┌──────────────┐     ┌──────────────┐   │   │
│    │    │  更新状态    │◀────│ PostgreSQL   │◀────│   Milvus     │   │   │
│    │    │ (COMPLETED)  │     │  (元数据)    │     │  (向量)      │   │   │
│    │    └──────────────┘     └──────────────┘     └──────────────┘   │   │
│    │                                                                    │   │
│    └──────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 AI功能实现细节

#### 5.2.1 AI服务配置与封装

**配置类设计**（AiServiceConfig.java）：

```java
@Data
@Configuration
@ConfigurationProperties(prefix = "ai")
public class AiServiceConfig {
    
    private EmbeddingConfig embedding = new EmbeddingConfig();
    private LlmConfig llm = new LlmConfig();
    
    @Data
    public static class EmbeddingConfig {
        private String apiKey;
        private String apiUrl = "https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings";
        private String model = "text-embedding-v3";
        private Integer dimension = 1024;
        private Integer batchSize = 10;
        private Integer maxRetries = 3;
    }
    
    @Data
    public static class LlmConfig {
        private String apiKey;
        private String apiUrl = "https://api.deepseek.com/v1/chat/completions";
        private String model = "deepseek-chat";
        private Integer maxTokens = 2000;
        private Double temperature = 0.7;
        private Integer timeout = 60;
    }
}
```

#### 5.2.2 Embedding服务实现

**EmbeddingServiceImpl核心代码**：

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class EmbeddingServiceImpl implements EmbeddingService {

    private final AiServiceConfig aiConfig;
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    private final OkHttpClient httpClient = new OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(60, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build();

    @Override
    public float[] embed(String text) {
        if (text == null || text.trim().isEmpty()) {
            return new float[getDimension()];
        }
        List<float[]> results = embedBatch(Collections.singletonList(text));
        return results.isEmpty() ? new float[getDimension()] : results.get(0);
    }

    @Override
    public List<float[]> embedBatch(List<String> texts) {
        List<float[]> allEmbeddings = new ArrayList<>();
        if (texts == null || texts.isEmpty()) {
            return allEmbeddings;
        }

        AiServiceConfig.EmbeddingConfig config = aiConfig.getEmbedding();
        int batchSize = config.getBatchSize();
        
        // 分批处理，避免单次请求过大
        for (int i = 0; i < texts.size(); i += batchSize) {
            int end = Math.min(i + batchSize, texts.size());
            List<String> batch = texts.subList(i, end);
            List<float[]> batchResult = doEmbedRequest(batch);
            allEmbeddings.addAll(batchResult);
            
            // 批次间延迟，避免频繁请求
            if (end < texts.size()) {
                try { Thread.sleep(100); } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
        return allEmbeddings;
    }

    private List<float[]> doEmbedRequest(List<String> texts) {
        AiServiceConfig.EmbeddingConfig config = aiConfig.getEmbedding();
        List<float[]> embeddings = new ArrayList<>();
        
        int retries = 0;
        while (retries < config.getMaxRetries()) {
            try {
                // 构建请求体
                Map<String, Object> requestBody = new HashMap<>();
                requestBody.put("model", config.getModel());
                requestBody.put("input", texts);
                
                Request request = new Request.Builder()
                        .url(config.getApiUrl())
                        .addHeader("Authorization", "Bearer " + config.getApiKey())
                        .addHeader("Content-Type", "application/json")
                        .post(RequestBody.create(
                            objectMapper.writeValueAsString(requestBody), 
                            MediaType.parse("application/json")))
                        .build();

                try (Response response = httpClient.newCall(request).execute()) {
                    if (!response.isSuccessful()) {
                        retries++;
                        continue;
                    }
                    
                    // 解析响应
                    JsonNode root = objectMapper.readTree(response.body().string());
                    JsonNode dataArray = root.get("data");
                    
                    if (dataArray != null && dataArray.isArray()) {
                        for (JsonNode item : dataArray) {
                            JsonNode embeddingNode = item.get("embedding");
                            if (embeddingNode != null && embeddingNode.isArray()) {
                                float[] embedding = new float[embeddingNode.size()];
                                for (int j = 0; j < embeddingNode.size(); j++) {
                                    embedding[j] = (float) embeddingNode.get(j).asDouble();
                                }
                                embeddings.add(embedding);
                            }
                        }
                    }
                    return embeddings;
                }
            } catch (IOException e) {
                log.error("Embedding API请求异常: {}", e.getMessage());
                retries++;
                if (retries < config.getMaxRetries()) {
                    try { Thread.sleep(1000 * retries); } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        }
        
        // 失败时返回零向量
        for (int i = 0; i < texts.size(); i++) {
            embeddings.add(new float[getDimension()]);
        }
        return embeddings;
    }

    @Override
    public int getDimension() {
        return aiConfig.getEmbedding().getDimension();
    }
}
```

#### 5.2.3 Tool Calling实现（AI自主判断检索）

**EnhancedRagServiceImpl核心实现**：

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class EnhancedRagServiceImpl implements EnhancedRagService {

    private final EnhancedLlmService enhancedLlmService;
    private final KnowledgeSearchTool knowledgeSearchTool;
    private final ObjectMapper objectMapper = new ObjectMapper();

    /** 系统提示词 - 定义AI角色和行为 */
    private static final String BASE_SYSTEM_PROMPT = """
            你是EchoCampus智能校园问答助手"小E"，专门回答与校园相关的问题。
            
            # 核心职责
            1. 当用户询问校园相关问题时，使用searchKnowledge工具查询知识库
            2. 基于知识库内容回答问题，不得编造信息
            3. 对于简单问候、闲聊等非知识性问题，可以直接回答
            
            # 知识库使用策略
            - 当问题涉及校园信息、课程、活动、设施等时，**必须**使用searchKnowledge工具
            - 对于问候语、感谢等简单交流，**无需**调用工具
            """;

    @Override
    public RagResponse answerWithAutoRetrieval(String question, List<Message> historyMessages,
                                              Long userId, Long conversationId) {
        long startTime = System.currentTimeMillis();
        
        // 构建上下文查询
        String contextualQuery = buildContextualQuery(question, historyMessages);
        
        // 获取工具规范
        List<ToolSpecification> tools = getToolSpecifications();
        
        // 创建工具执行器
        EnhancedLlmService.ToolExecutor toolExecutor = (toolName, arguments) -> {
            try {
                if ("searchKnowledge".equals(toolName)) {
                    Map<String, Object> args = objectMapper.readValue(arguments, Map.class);
                    String query = (String) args.get("query");
                    log.info("AI决定检索知识库: query={}", query);
                    return knowledgeSearchTool.searchKnowledge(query);
                }
                return "未知工具: " + toolName;
            } catch (Exception e) {
                return "工具执行失败: " + e.getMessage();
            }
        };
        
        // 调用LLM服务（支持Tool Calling）
        String answer = enhancedLlmService.chatWithTools(
                BASE_SYSTEM_PROMPT, contextualQuery, historyMessages, tools, toolExecutor);
        
        List<SourceInfo> sources = extractSourcesFromAnswer(answer, contextualQuery);
        long responseTime = System.currentTimeMillis() - startTime;
        
        return new RagResponse(answer, sources, responseTime);
    }

    /**
     * 构建工具规范
     */
    private List<ToolSpecification> getToolSpecifications() {
        Map<String, Map<String, Object>> properties = new HashMap<>();
        Map<String, Object> queryParam = new HashMap<>();
        queryParam.put("type", "string");
        queryParam.put("description", "要搜索的问题或关键词");
        properties.put("query", queryParam);
        
        ToolParameters params = ToolParameters.builder()
                .properties(properties)
                .required(Collections.singletonList("query"))
                .build();
        
        ToolSpecification spec = ToolSpecification.builder()
                .name("searchKnowledge")
                .description("在校园知识库中搜索相关信息")
                .parameters(params)
                .build();
        
        return Collections.singletonList(spec);
    }
}
```

#### 5.2.4 知识检索工具实现

**KnowledgeSearchTool核心代码**：

```java
@Slf4j
@Component
@RequiredArgsConstructor
public class KnowledgeSearchTool {

    private final EmbeddingService embeddingService;
    private final MilvusService milvusService;
    private final KnowledgeChunkMapper chunkMapper;
    private final KnowledgeDocMapper docMapper;

    @Value("${rag.top-k:5}")
    private int defaultTopK;

    @Value("${rag.similarity-threshold:0.6}")
    private float similarityThreshold;

    /**
     * 知识库检索方法 - 供AI通过Tool Calling调用
     */
    @Tool("在校园知识库中搜索相关信息")
    public String searchKnowledge(String query) {
        log.info("AI调用知识库检索工具: query={}", query);
        
        try {
            // 1. 将查询向量化
            float[] queryVector = embeddingService.embed(query);
            if (queryVector == null || allZeros(queryVector)) {
                return "知识库检索失败：无法向量化查询内容";
            }

            // 2. 在Milvus中搜索相似向量
            List<MilvusService.SearchResult> searchResults = 
                    milvusService.search(queryVector, defaultTopK, similarityThreshold);

            if (searchResults.isEmpty()) {
                return "知识库中未找到相关内容";
            }

            // 3. 获取完整的知识片段
            List<Long> chunkIds = searchResults.stream()
                    .map(MilvusService.SearchResult::getChunkId)
                    .collect(Collectors.toList());
            List<KnowledgeChunk> chunks = chunkMapper.selectBatchIds(chunkIds);
            
            // 4. 按相似度排序
            Map<Long, Float> scoreMap = searchResults.stream()
                    .collect(Collectors.toMap(
                            MilvusService.SearchResult::getChunkId,
                            MilvusService.SearchResult::getScore));
            chunks.sort((a, b) -> scoreMap.getOrDefault(b.getId(), 0f)
                    .compareTo(scoreMap.getOrDefault(a.getId(), 0f)));

            // 5. 格式化输出
            return formatKnowledgeResult(chunks, scoreMap);

        } catch (Exception e) {
            log.error("知识库检索失败: {}", e.getMessage());
            return "知识库检索出现错误：" + e.getMessage();
        }
    }

    private String formatKnowledgeResult(List<KnowledgeChunk> chunks, Map<Long, Float> scoreMap) {
        // 获取文档信息
        Set<Long> docIds = chunks.stream().map(KnowledgeChunk::getDocId).collect(Collectors.toSet());
        Map<Long, KnowledgeDoc> docMap = docMapper.selectBatchIds(docIds).stream()
                .collect(Collectors.toMap(KnowledgeDoc::getId, doc -> doc));

        StringBuilder result = new StringBuilder();
        result.append("【知识库检索结果】\n");
        result.append(String.format("找到 %d 个相关内容片段：\n\n", chunks.size()));

        for (int i = 0; i < chunks.size(); i++) {
            KnowledgeChunk chunk = chunks.get(i);
            KnowledgeDoc doc = docMap.get(chunk.getDocId());
            
            if (doc != null) {
                result.append(String.format("--- 来源：%s ---\n", doc.getTitle()));
            }
            result.append(String.format("[片段%d] [相关度:%.2f]\n", 
                    i + 1, scoreMap.getOrDefault(chunk.getId(), 0f)));
            result.append(chunk.getContent().trim());
            result.append("\n\n");
        }
        return result.toString();
    }
}
```

#### 5.2.5 文本切块服务实现

**TextChunkServiceImpl基于LangChain4j的实现**：

```java
@Slf4j
@Service
public class TextChunkServiceImpl implements TextChunkService {

    @Value("${document.chunking.max-size:500}")
    private int defaultMaxSize;

    @Value("${document.chunking.overlap-size:50}")
    private int defaultOverlapSize;

    @Override
    public List<KnowledgeChunk> chunkText(String text, Long docId, String fileType) {
        ChunkConfig config = getConfigByFileType(fileType);
        return doChunk(text, docId, config.maxSize, config.overlapSize);
    }

    private List<KnowledgeChunk> doChunk(String text, Long docId, int maxSize, int overlapSize) {
        List<KnowledgeChunk> chunks = new ArrayList<>();
        if (text == null || text.trim().isEmpty()) {
            return chunks;
        }

        text = preprocessText(text);

        try {
            // 创建LangChain4j Document
            Document document = Document.from(text);

            // 使用分层分割策略：段落 → 句子 → 字符
            DocumentSplitter splitter = createHierarchicalSplitter(maxSize, overlapSize);
            List<TextSegment> segments = splitter.split(document);

            // 转换为KnowledgeChunk
            int position = 0;
            for (int i = 0; i < segments.size(); i++) {
                TextSegment segment = segments.get(i);
                String content = segment.text().trim();
                if (content.isEmpty()) continue;

                KnowledgeChunk chunk = new KnowledgeChunk();
                chunk.setDocId(docId);
                chunk.setChunkIndex(i);
                chunk.setContent(content);
                chunk.setStartPosition(position);
                chunk.setEndPosition(position + content.length());
                chunk.setTokenCount(estimateTokenCount(content));
                chunks.add(chunk);
                position += content.length();
            }

            log.info("文本切块完成: docId={}, 切块数={}", docId, chunks.size());
        } catch (Exception e) {
            log.error("切块失败，回退到简单分割: {}", e.getMessage());
            chunks = fallbackSplit(text, docId, maxSize, overlapSize);
        }
        return chunks;
    }

    /**
     * 创建分层分割器（段落 → 句子 → 字符）
     */
    private DocumentSplitter createHierarchicalSplitter(int maxSize, int overlapSize) {
        // 字符级分割器（兜底）
        DocumentSplitter charSplitter = new DocumentByCharacterSplitter(maxSize, overlapSize);
        // 句子级分割器
        DocumentSplitter sentenceSplitter = new DocumentBySentenceSplitter(maxSize, overlapSize, charSplitter);
        // 段落级分割器
        return new DocumentByParagraphSplitter(maxSize, overlapSize, sentenceSplitter);
    }

    /**
     * 根据文件类型获取切块配置
     */
    private ChunkConfig getConfigByFileType(String fileType) {
        if (fileType == null) {
            return new ChunkConfig(defaultMaxSize, defaultOverlapSize);
        }
        return switch (fileType.toLowerCase()) {
            case "pdf" -> new ChunkConfig(800, 100);
            case "md", "markdown" -> new ChunkConfig(600, 80);
            case "docx", "doc" -> new ChunkConfig(700, 90);
            case "pptx", "ppt" -> new ChunkConfig(400, 50);
            default -> new ChunkConfig(defaultMaxSize, defaultOverlapSize);
        };
    }

    private record ChunkConfig(int maxSize, int overlapSize) {}
}
```

### 5.3 主要功能流程图

#### 5.3.1 RAG问答完整流程图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           RAG问答完整流程                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│    用户输入问题                                                              │
│         │                                                                    │
│         ▼                                                                    │
│    ┌──────────────────┐                                                     │
│    │  ChatController  │                                                     │
│    │  接收请求        │                                                     │
│    └────────┬─────────┘                                                     │
│             │                                                                │
│             ▼                                                                │
│    ┌──────────────────┐                                                     │
│    │   ChatService    │                                                     │
│    │ 1. 创建/获取会话 │                                                     │
│    │ 2. 保存用户消息  │                                                     │
│    │ 3. 获取历史上下文│                                                     │
│    └────────┬─────────┘                                                     │
│             │                                                                │
│             ▼                                                                │
│    ┌──────────────────────────────────────────────────────────────────┐    │
│    │                    EnhancedRagService                             │    │
│    │                                                                    │    │
│    │    ┌────────────────────────────────────────────────────────┐    │    │
│    │    │  1. 构建上下文查询 (结合历史对话)                        │    │    │
│    │    └────────────────────────────────────────────────────────┘    │    │
│    │                              │                                    │    │
│    │                              ▼                                    │    │
│    │    ┌────────────────────────────────────────────────────────┐    │    │
│    │    │  2. 调用EnhancedLlmService (带Tool规范)                  │    │    │
│    │    └────────────────────────────────────────────────────────┘    │    │
│    │                              │                                    │    │
│    └──────────────────────────────┼────────────────────────────────────┘    │
│                                   │                                         │
│                                   ▼                                         │
│    ┌──────────────────────────────────────────────────────────────────┐    │
│    │                     EnhancedLlmService                            │    │
│    │                                                                    │    │
│    │    ┌────────────────────────────────────────────────────────┐    │    │
│    │    │  1. 构建消息列表 (system + history + user)               │    │    │
│    │    │  2. 构建Tool定义 (searchKnowledge)                       │    │    │
│    │    │  3. 调用DeepSeek API                                     │    │    │
│    │    └────────────────────────────────────────────────────────┘    │    │
│    │                              │                                    │    │
│    │                              ▼                                    │    │
│    │                     ┌───────────────┐                            │    │
│    │                     │ AI判断是否需要│                            │    │
│    │                     │  检索知识库   │                            │    │
│    │                     └───────┬───────┘                            │    │
│    │                             │                                     │    │
│    │              ┌──────────────┴──────────────┐                     │    │
│    │              │                             │                     │    │
│    │              ▼ 是                          ▼ 否                  │    │
│    │    ┌─────────────────┐           ┌─────────────────┐            │    │
│    │    │ 返回tool_calls  │           │ 直接返回content │            │    │
│    │    │ searchKnowledge │           │   (无需检索)    │            │    │
│    │    └────────┬────────┘           └────────┬────────┘            │    │
│    │             │                              │                     │    │
│    └─────────────┼──────────────────────────────┼─────────────────────┘    │
│                  │                              │                          │
│                  ▼                              │                          │
│    ┌──────────────────────────────────┐        │                          │
│    │      KnowledgeSearchTool         │        │                          │
│    │                                  │        │                          │
│    │  1. EmbeddingService.embed()     │        │                          │
│    │     (问题向量化)                  │        │                          │
│    │              │                   │        │                          │
│    │              ▼                   │        │                          │
│    │  2. MilvusService.search()       │        │                          │
│    │     (向量相似度检索)             │        │                          │
│    │              │                   │        │                          │
│    │              ▼                   │        │                          │
│    │  3. 获取知识片段并格式化         │        │                          │
│    │              │                   │        │                          │
│    └──────────────┼───────────────────┘        │                          │
│                   │                             │                          │
│                   ▼                             │                          │
│    ┌──────────────────────────────────────────┐│                          │
│    │ 将检索结果作为tool消息返回给LLM         ││                          │
│    │ 继续生成最终回答                         ││                          │
│    └──────────────────────────────────────────┘│                          │
│                   │                             │                          │
│                   └──────────────┬──────────────┘                          │
│                                  │                                         │
│                                  ▼                                         │
│                        ┌─────────────────┐                                 │
│                        │   最终AI回答    │                                 │
│                        └────────┬────────┘                                 │
│                                 │                                          │
│                                 ▼                                          │
│                        ┌─────────────────┐                                 │
│                        │  保存BOT消息    │                                 │
│                        │  返回响应       │                                 │
│                        └─────────────────┘                                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 5.3.2 文档处理流程图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           文档处理流程                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│    ┌──────────────┐                                                        │
│    │   文件上传   │                                                        │
│    └───────┬──────┘                                                        │
│            │                                                                │
│            ▼                                                                │
│    ┌──────────────┐     No     ┌──────────────┐                           │
│    │  文件类型    │───────────▶│   返回错误   │                           │
│    │   校验？     │            │   响应       │                           │
│    └───────┬──────┘            └──────────────┘                           │
│            │ Yes                                                           │
│            ▼                                                                │
│    ┌──────────────┐     No     ┌──────────────┐                           │
│    │  文件大小    │───────────▶│   返回错误   │                           │
│    │   校验？     │            │   响应       │                           │
│    └───────┬──────┘            └──────────────┘                           │
│            │ Yes                                                           │
│            ▼                                                                │
│    ┌──────────────┐                                                        │
│    │  保存文件    │                                                        │
│    │  创建记录    │                                                        │
│    │ (status=     │                                                        │
│    │  PROCESSING) │                                                        │
│    └───────┬──────┘                                                        │
│            │                                                                │
│            ▼                                                                │
│    ┌──────────────────────────────────────────────────────────────────┐   │
│    │                    @Async 异步处理                                │   │
│    │                                                                    │   │
│    │    ┌──────────────┐                                               │   │
│    │    │根据file_type │                                               │   │
│    │    │选择解析器    │                                               │   │
│    │    └───────┬──────┘                                               │   │
│    │            │                                                       │   │
│    │            ▼                                                       │   │
│    │    ┌──────────────────────────────────────────────────────┐      │   │
│    │    │              DocumentParserFactory                    │      │   │
│    │    │    ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐      │      │   │
│    │    │    │  PDF   │ │  TXT   │ │  DOCX  │ │  PPT   │      │      │   │
│    │    │    │ Parser │ │ Parser │ │ Parser │ │ Parser │      │      │   │
│    │    │    └────────┘ └────────┘ └────────┘ └────────┘      │      │   │
│    │    └──────────────────────────────────────────────────────┘      │   │
│    │            │                                                       │   │
│    │            ▼                                                       │   │
│    │    ┌──────────────┐                                               │   │
│    │    │TextChunkSvc  │                                               │   │
│    │    │智能切块      │                                               │   │
│    │    │(LangChain4j) │                                               │   │
│    │    └───────┬──────┘                                               │   │
│    │            │                                                       │   │
│    │            ▼                                                       │   │
│    │    ┌──────────────┐                                               │   │
│    │    │EmbeddingSvc  │                                               │   │
│    │    │批量向量化    │                                               │   │
│    │    └───────┬──────┘                                               │   │
│    │            │                                                       │   │
│    │            ▼                                                       │   │
│    │    ┌──────────────┐      ┌──────────────┐                        │   │
│    │    │ MilvusSvc    │      │ PostgreSQL   │                        │   │
│    │    │ 存储向量     │      │ 存储元数据   │                        │   │
│    │    └──────────────┘      └──────────────┘                        │   │
│    │            │                      │                                │   │
│    │            └──────────┬───────────┘                                │   │
│    │                       │                                            │   │
│    │                       ▼                                            │   │
│    │               ┌──────────────┐                                    │   │
│    │               │ 更新文档状态 │                                    │   │
│    │               │ (COMPLETED)  │                                    │   │
│    │               └──────────────┘                                    │   │
│    │                                                                    │   │
│    └──────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.4 关键技术实现代码

#### 5.4.1 流式响应实现

**ChatController流式接口**：

```java
@Operation(summary = "发送消息（流式）", description = "发送消息并获取流式AI回复")
@PostMapping(value = "/message/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public SseEmitter sendMessageStream(HttpServletRequest request, 
                                   @Valid @RequestBody ChatRequest chatRequest) {
    Long userId = (Long) request.getAttribute("userId");
    
    // 限流检查
    if (!rateLimiter.tryAcquire(userId)) {
        throw new BusinessException(ResultCode.SYSTEM_BUSY, "系统繁忙，请稍后再试");
    }
    
    // 创建SSE发射器，超时时间5分钟
    SseEmitter emitter = new SseEmitter(300000L);
    
    // 异步执行流式响应
    sseExecutor.execute(() -> {
        try {
            chatService.sendMessageStream(userId, chatRequest, streamResponse -> {
                try {
                    String json = objectMapper.writeValueAsString(streamResponse);
                    emitter.send(SseEmitter.event()
                            .name(streamResponse.getType().name().toLowerCase())
                            .data(json));
                } catch (IOException e) {
                    emitter.completeWithError(e);
                }
            });
            emitter.complete();
        } catch (Exception e) {
            emitter.completeWithError(e);
        }
    });
    
    // 设置回调
    emitter.onCompletion(() -> rateLimiter.release(userId));
    emitter.onTimeout(() -> { emitter.complete(); rateLimiter.release(userId); });
    emitter.onError(e -> rateLimiter.release(userId));
    
    return emitter;
}
```

#### 5.4.2 Milvus向量数据库操作

**MilvusServiceImpl关键方法**：

```java
@Override
public List<SearchResult> search(float[] queryVector, int topK, float threshold) {
    if (milvusClient == null) {
        return Collections.emptyList();
    }

    // 转换查询向量格式
    List<Float> queryVectorList = new ArrayList<>();
    for (float v : queryVector) {
        queryVectorList.add(v);
    }

    SearchParam searchParam = SearchParam.newBuilder()
            .withCollectionName(milvusConfig.getCollectionName())
            .withMetricType(MetricType.valueOf(milvusConfig.getMetricType()))
            .withOutFields(Arrays.asList("id", "chunk_id", "doc_id", "content", "category"))
            .withTopK(topK)
            .withVectors(Collections.singletonList(queryVectorList))
            .withVectorFieldName("vector")
            .withParams("{\"nprobe\":" + milvusConfig.getNprobe() + "}")
            .build();

    R<SearchResults> searchResult = milvusClient.search(searchParam);
    if (searchResult.getStatus() != R.Status.Success.getCode()) {
        log.error("向量搜索失败: {}", searchResult.getMessage());
        return Collections.emptyList();
    }

    List<SearchResult> results = new ArrayList<>();
    SearchResultsWrapper wrapper = new SearchResultsWrapper(searchResult.getData().getResults());
    
    for (int i = 0; i < wrapper.getRowRecords(0).size(); i++) {
        QueryResultsWrapper.RowRecord row = wrapper.getRowRecords(0).get(i);
        float score = (float) wrapper.getIDScore(0).get(i).getScore();
        
        // COSINE相似度转换
        float similarity = (1 + score) / 2;
        if (similarity < threshold) continue;

        SearchResult result = new SearchResult();
        result.setVectorId(row.get("id").toString());
        result.setChunkId((Long) row.get("chunk_id"));
        result.setDocId((Long) row.get("doc_id"));
        result.setContent(row.get("content").toString());
        result.setScore(similarity);
        results.add(result);
    }

    return results;
}
```

#### 5.4.3 文档解析器工厂模式

**DocumentParserFactory实现**：

```java
@Component
@RequiredArgsConstructor
public class DocumentParserFactory {

    private final PdfDocumentParser pdfParser;
    private final TxtDocumentParser txtParser;
    private final MarkdownDocumentParser markdownParser;
    private final DocxDocumentParser docxParser;
    private final DocDocumentParser docParser;
    private final PptDocumentParser pptParser;

    /**
     * 根据文件类型获取对应的解析器
     */
    public DocumentParser getParser(String fileType) {
        if (fileType == null) {
            throw new DocumentParseException("文件类型不能为空");
        }
        
        return switch (fileType.toLowerCase()) {
            case "pdf" -> pdfParser;
            case "txt" -> txtParser;
            case "md", "markdown" -> markdownParser;
            case "docx" -> docxParser;
            case "doc" -> docParser;
            case "ppt", "pptx" -> pptParser;
            default -> throw new DocumentParseException("不支持的文件类型: " + fileType);
        };
    }
    
    /**
     * 获取支持的文件类型列表
     */
    public List<String> getSupportedTypes() {
        return Arrays.asList("pdf", "txt", "md", "docx", "doc", "ppt", "pptx");
    }
}
```

### 5.5 单元测试与集成测试

#### 5.5.1 服务层单元测试示例

```java
@SpringBootTest
@Transactional
class ChatServiceTest {

    @Autowired
    private ChatService chatService;
    
    @Autowired
    private UserMapper userMapper;

    @Test
    void testCreateConversation() {
        // 准备测试数据
        User user = new User();
        user.setUsername("testuser");
        user.setPassword("encodedPassword");
        userMapper.insert(user);
        
        // 执行测试
        Conversation conversation = chatService.createConversation(user.getId(), "测试会话");
        
        // 验证结果
        assertNotNull(conversation);
        assertNotNull(conversation.getId());
        assertEquals("测试会话", conversation.getTitle());
        assertEquals(user.getId(), conversation.getUserId());
    }

    @Test
    void testGetConversations() {
        // ... 测试获取会话列表
    }
}
```

#### 5.5.2 AI服务集成测试示例

```java
@SpringBootTest
class EmbeddingServiceIntegrationTest {

    @Autowired
    private EmbeddingService embeddingService;

    @Test
    @Disabled("需要配置真实API Key")
    void testEmbed() {
        String text = "上海应用技术大学在哪里？";
        float[] vector = embeddingService.embed(text);
        
        assertNotNull(vector);
        assertEquals(1024, vector.length);  // Qwen3-Embedding维度
        
        // 验证不是零向量
        boolean hasNonZero = false;
        for (float v : vector) {
            if (v != 0) {
                hasNonZero = true;
                break;
            }
        }
        assertTrue(hasNonZero);
    }
}
```

---


## 第六章 系统部署与运维

### 6.1 项目打包与构建

#### 6.1.1 后端构建

后端项目使用Maven进行构建，通过Spring Boot Maven插件打包为可执行JAR文件。

**Maven构建命令**：

```bash
# 进入后端目录
cd backend

# 清理并打包（跳过测试）
mvn clean package -DskipTests

# 打包结果：target/echocampus-bot-1.0.0.jar
```

**pom.xml关键配置**：

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <excludes>
                    <exclude>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                    </exclude>
                </excludes>
            </configuration>
        </plugin>
    </plugins>
</build>
```

#### 6.1.2 前端构建

前端项目使用Vite进行构建，生成静态资源文件。

**前端构建命令**：

```bash
# 进入前端目录
cd frontend

# 安装依赖
pnpm install

# 生产环境构建
pnpm run build

# 构建结果：dist/目录
```

**Vite配置（vite.config.ts）**：

```typescript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
    },
  },
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: false,
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true,
      },
    },
  },
})
```

### 6.2 Docker容器化部署

#### 6.2.1 后端Dockerfile

```dockerfile
# backend/Dockerfile
FROM eclipse-temurin:17-jre-alpine

WORKDIR /app

# 安装curl用于健康检查
RUN apk add --no-cache curl

# 复制构建产物
COPY target/echocampus-bot-1.0.0.jar app.jar

# 创建非root用户
RUN addgroup -S spring && adduser -S spring -G spring && \
    mkdir -p /app/uploads /app/logs && \
    chown -R spring:spring /app/uploads /app/logs

USER spring:spring

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
```

#### 6.2.2 Docker Compose编排

完整的docker-compose.yml配置，实现一键部署所有服务：

```yaml
version: '3.8'

services:
  # PostgreSQL数据库
  postgres:
    container_name: echocampus-postgres
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-echocampus_bot}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres123}
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docs/数据库设计.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - echocampus-network
    restart: unless-stopped

  # Milvus向量数据库 - 单机版
  milvus-standalone:
    container_name: milvus-standalone
    image: milvusdb/milvus:v2.3.4
    command: ["milvus", "run", "standalone"]
    environment:
      ETCD_ENDPOINTS: etcd:2379
      MINIO_ADDRESS: minio:9000
      MINIO_ACCESS_KEY: minioadmin
      MINIO_SECRET_KEY: minioadmin
    volumes:
      - milvus_data:/var/lib/milvus
    ports:
      - "19530:19530"
      - "9091:9091"
    depends_on:
      - etcd
      - minio
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9091/healthz"]
      interval: 30s
      start_period: 90s
      timeout: 20s
      retries: 3
    networks:
      - echocampus-network
    restart: unless-stopped

  # etcd - Milvus元数据存储
  etcd:
    container_name: milvus-etcd
    image: quay.io/coreos/etcd:v3.5.5
    environment:
      - ETCD_AUTO_COMPACTION_MODE=revision
      - ETCD_AUTO_COMPACTION_RETENTION=1000
      - ETCD_QUOTA_BACKEND_BYTES=4294967296
    volumes:
      - etcd_data:/etcd
    command: etcd -advertise-client-urls=http://127.0.0.1:2379 -listen-client-urls http://0.0.0.0:2379 --data-dir /etcd
    networks:
      - echocampus-network
    restart: unless-stopped

  # MinIO - Milvus对象存储
  minio:
    container_name: milvus-minio
    image: minio/minio:RELEASE.2023-03-20T20-16-18Z
    environment:
      MINIO_ACCESS_KEY: minioadmin
      MINIO_SECRET_KEY: minioadmin
    volumes:
      - minio_data:/minio_data
    command: minio server /minio_data --console-address ":9001"
    ports:
      - "9000:9000"
      - "9001:9001"
    networks:
      - echocampus-network
    restart: unless-stopped

  # 后端服务
  echocampus-bot:
    container_name: echocampus-bot
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/${POSTGRES_DB:-echocampus_bot}
      SPRING_DATASOURCE_USERNAME: ${POSTGRES_USER:-postgres}
      SPRING_DATASOURCE_PASSWORD: ${POSTGRES_PASSWORD:-postgres123}
      MILVUS_HOST: milvus-standalone
      MILVUS_PORT: 19530
      ALIYUN_API_KEY: ${ALIYUN_API_KEY}
      DEEPSEEK_API_KEY: ${DEEPSEEK_API_KEY}
      JWT_SECRET: ${JWT_SECRET}
      DOCUMENT_UPLOAD_PATH: /app/uploads
    volumes:
      - uploads_data:/app/uploads
      - logs_data:/app/logs
    ports:
      - "${BACKEND_PORT:-8083}:8080"
    depends_on:
      postgres:
        condition: service_healthy
      milvus-standalone:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/v1/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - echocampus-network
    restart: unless-stopped

networks:
  echocampus-network:
    driver: bridge

volumes:
  postgres_data:
  milvus_data:
  etcd_data:
  minio_data:
  uploads_data:
  logs_data:
```

#### 6.2.3 环境变量配置

创建`.env`文件配置敏感信息：

```bash
# .env 文件示例

# 数据库配置
POSTGRES_DB=echocampus_bot
POSTGRES_USER=postgres
POSTGRES_PASSWORD=your_secure_password

# AI服务密钥
ALIYUN_API_KEY=your_aliyun_api_key
DEEPSEEK_API_KEY=your_deepseek_api_key

# JWT密钥
JWT_SECRET=your_jwt_secret_key_at_least_32_characters

# 端口配置
BACKEND_PORT=8083
POSTGRES_PORT=5432
```

### 6.3 服务启动与守护

#### 6.3.1 部署流程

```bash
# 1. 克隆项目
git clone https://github.com/your-repo/EchoCampus-Bot.git
cd EchoCampus-Bot

# 2. 配置环境变量
cp .env.example .env
# 编辑 .env 文件，填入实际配置

# 3. 构建后端（如果需要）
cd backend
mvn clean package -DskipTests
cd ..

# 4. 启动所有服务
docker-compose up -d

# 5. 查看服务状态
docker-compose ps

# 6. 查看日志
docker-compose logs -f echocampus-bot

# 7. 检查健康状态
curl http://localhost:8083/api/v1/health
```

#### 6.3.2 服务管理命令

```bash
# 启动服务
docker-compose up -d

# 停止服务
docker-compose down

# 重启单个服务
docker-compose restart echocampus-bot

# 查看服务日志
docker-compose logs -f [service_name]

# 进入容器
docker exec -it echocampus-bot /bin/sh

# 查看资源使用
docker stats
```

#### 6.3.3 服务健康监控

系统提供健康检查接口，用于监控服务状态：

```java
@RestController
@RequestMapping("/v1")
public class HealthController {

    @Autowired
    private MilvusService milvusService;
    
    @Autowired
    private DataSource dataSource;

    @GetMapping("/health")
    public Result<Map<String, Object>> health() {
        Map<String, Object> status = new HashMap<>();
        
        // 检查数据库连接
        try {
            dataSource.getConnection().isValid(5);
            status.put("database", "healthy");
        } catch (Exception e) {
            status.put("database", "unhealthy: " + e.getMessage());
        }
        
        // 检查Milvus连接
        status.put("milvus", milvusService.isAvailable() ? "healthy" : "unavailable");
        
        // 系统信息
        status.put("timestamp", System.currentTimeMillis());
        status.put("version", "1.0.0");
        
        return Result.success(status);
    }
}
```

---

## 第七章 系统测试

### 7.1 功能测试

#### 7.1.1 用户模块测试用例

| 测试编号 | 测试项目 | 输入数据 | 预期结果 | 实际结果 | 状态 |
|----------|----------|----------|----------|----------|------|
| U-001 | 用户注册 | 合法用户名、密码、邮箱 | 注册成功，发送验证码 | 符合预期 | 通过 |
| U-002 | 用户登录 | 正确用户名密码 | 返回JWT Token | 符合预期 | 通过 |
| U-003 | 登录失败 | 错误密码 | 返回认证失败 | 符合预期 | 通过 |
| U-004 | Token验证 | 有效JWT Token | 请求通过 | 符合预期 | 通过 |
| U-005 | Token过期 | 过期JWT Token | 返回401未授权 | 符合预期 | 通过 |

#### 7.1.2 对话模块测试用例

| 测试编号 | 测试项目 | 输入数据 | 预期结果 | 实际结果 | 状态 |
|----------|----------|----------|----------|----------|------|
| C-001 | 创建会话 | 会话标题 | 创建成功，返回会话ID | 符合预期 | 通过 |
| C-002 | 发送问题 | "学校食堂在哪里" | 返回知识库相关回答 | 符合预期 | 通过 |
| C-003 | 简单问候 | "你好" | 直接回答，不检索 | 符合预期 | 通过 |
| C-004 | 流式响应 | 问题消息 | SSE事件流输出 | 符合预期 | 通过 |
| C-005 | 历史记录 | 会话ID | 返回消息列表 | 符合预期 | 通过 |

#### 7.1.3 AI功能测试用例（20%权重）

| 测试编号 | 测试项目 | 输入数据 | 预期结果 | 实际结果 | 状态 |
|----------|----------|----------|----------|----------|------|
| AI-001 | 知识库检索 | 校园相关问题 | 返回相关知识片段 | 符合预期 | 通过 |
| AI-002 | 向量相似度 | 语义相近的问题 | 检索到相同知识 | 符合预期 | 通过 |
| AI-003 | Tool Calling | 需要检索的问题 | AI自动调用检索工具 | 符合预期 | 通过 |
| AI-004 | 直接回答 | 简单闲聊 | 不调用工具直接回答 | 符合预期 | 通过 |
| AI-005 | 多轮对话 | 追问"这个呢？" | 理解上下文回答 | 符合预期 | 通过 |
| AI-006 | 知识来源 | 知识问答 | 返回来源文档信息 | 符合预期 | 通过 |

### 7.2 接口测试

#### 7.2.1 API接口测试结果

使用Postman/Insomnia进行接口测试：

**聊天接口测试**：

```
POST /api/v1/chat/message/stream
Content-Type: application/json
Authorization: Bearer {token}

Request:
{
    "message": "上应大有哪些图书馆？"
}

Response (SSE):
event: status
data: {"type":"STATUS","content":"正在智能分析您的问题..."}

event: status
data: {"type":"STATUS","content":"🔍 正在检索：上应大图书馆"}

event: sources
data: {"type":"SOURCES","sources":[{"docId":1,"title":"校园设施指南","similarity":0.89}]}

event: content
data: {"type":"CONTENT","content":"上海应用技术大学..."}

event: done
data: {"type":"DONE","messageId":123}

测试结果：通过
```

**知识库接口测试**：

```
POST /api/v1/knowledge/docs
Content-Type: multipart/form-data
Authorization: Bearer {token}

Request:
- file: [PDF文件]
- title: 校园指南
- category: 校园介绍

Response:
{
    "code": 200,
    "message": "success",
    "data": {
        "id": 1,
        "title": "校园指南",
        "status": "PROCESSING"
    }
}

测试结果：通过
```

### 7.3 性能测试

#### 7.3.1 响应时间测试

| 接口 | 并发数 | 平均响应时间 | P95响应时间 | 最大响应时间 |
|------|--------|--------------|-------------|--------------|
| 健康检查 | 100 | 12ms | 25ms | 80ms |
| 获取会话列表 | 50 | 45ms | 120ms | 300ms |
| 发送消息（非流式） | 10 | 2.5s | 4s | 6s |
| 向量检索 | 20 | 180ms | 350ms | 500ms |

#### 7.3.2 并发能力测试

使用JMeter进行压力测试：

```
测试配置：
- 线程数：50
- 循环次数：100
- 目标接口：GET /v1/chat/conversations

测试结果：
- 总请求数：5000
- 成功率：99.8%
- 平均响应时间：78ms
- 吞吐量：45.2 req/s
```

### 7.4 部署验证测试

#### 7.4.1 云部署验证（20%权重）

| 测试项 | 预期结果 | 实际结果 | 状态 |
|--------|----------|----------|------|
| Docker容器启动 | 所有服务正常启动 | 符合预期 | 通过 |
| PostgreSQL连接 | 数据库可访问 | 符合预期 | 通过 |
| Milvus连接 | 向量数据库可用 | 符合预期 | 通过 |
| API网关 | 请求正确路由 | 符合预期 | 通过 |
| 健康检查 | 返回健康状态 | 符合预期 | 通过 |
| 日志持久化 | 日志正确写入 | 符合预期 | 通过 |

#### 7.4.2 部署验证命令

```bash
# 验证所有服务运行状态
docker-compose ps

# 输出示例：
# NAME                  STATUS                   PORTS
# echocampus-bot       Up (healthy)             0.0.0.0:8083->8080/tcp
# echocampus-postgres  Up (healthy)             0.0.0.0:5432->5432/tcp
# milvus-standalone    Up (healthy)             0.0.0.0:19530->19530/tcp
# milvus-etcd          Up                       2379/tcp
# milvus-minio         Up                       9000/tcp, 9001/tcp

# 验证健康检查接口
curl http://localhost:8083/api/v1/health

# 输出示例：
# {"code":200,"message":"success","data":{"database":"healthy","milvus":"healthy"}}
```

---

## 第八章 项目总结

### 8.1 项目收获与心得

#### 8.1.1 技术能力提升

通过本项目的开发，团队成员在以下方面获得了显著的技术提升：

**后端开发能力**：
- 深入理解Spring Boot 3.x生态和自动配置机制
- 掌握MyBatis-Plus的高级用法和性能优化
- 学习Spring Security + JWT的无状态认证实现
- 理解异步编程和SSE流式响应技术

**AI技术应用能力**：
- 深入理解RAG（检索增强生成）架构设计
- 掌握向量数据库Milvus的使用和调优
- 学习LangChain4j框架的核心概念和API
- 理解Embedding模型和LLM的工程化应用
- 实践Tool Calling/Function Calling技术

**前端开发能力**：
- 掌握Vue.js 3 Composition API
- 学习TypeScript类型系统
- 理解Pinia状态管理模式
- 实现SSE流式数据处理

**DevOps能力**：
- 掌握Docker容器化技术
- 学习Docker Compose多服务编排
- 理解健康检查和服务监控

#### 8.1.2 工程实践心得

1. **分层架构的重要性**：清晰的MVC分层使代码职责明确，便于维护和测试
2. **接口设计优先**：RESTful API规范和统一响应格式提升了前后端协作效率
3. **配置外部化**：敏感配置通过环境变量注入，提高了安全性和灵活性
4. **异步处理思维**：文档处理等耗时操作采用异步方式，提升用户体验
5. **容错设计**：API调用的重试机制和降级策略确保系统稳定性

### 8.2 遇到的困难及解决方案

#### 8.2.1 技术难点

**难点一：RAG检索质量优化**

问题描述：初期实现的RAG检索经常返回不相关的结果，回答质量不佳。

解决方案：
1. 调整相似度阈值，过滤低相关性结果（threshold=0.6）
2. 优化文本切块策略，使用LangChain4j的分层分割器保持语义完整
3. 根据文档类型动态调整切块参数（PDF: 800字符, PPT: 400字符）
4. 引入Top-K参数控制，避免返回过多噪音结果

**难点二：Tool Calling集成**

问题描述：LangChain4j的Tool注解方式在Spring环境下配置复杂。

解决方案：
1. 手动构建ToolSpecification对象，避免依赖复杂的反射机制
2. 自定义ToolExecutor接口，实现灵活的工具执行逻辑
3. 支持多轮Tool调用迭代（max_iterations=5）

**难点三：流式响应稳定性**

问题描述：SSE流式响应在网络不稳定时容易断开。

解决方案：
1. 设置合理的超时时间（5分钟）
2. 实现onCompletion/onTimeout/onError回调
3. 前端实现断线重连机制
4. 限流保护防止资源耗尽

#### 8.2.2 云部署问题

**问题一：Milvus启动慢导致后端连接失败**

解决方案：
1. 使用Docker健康检查（healthcheck）
2. 配置depends_on的condition: service_healthy
3. 后端增加Milvus可用性检查和优雅降级

**问题二：API密钥安全管理**

解决方案：
1. 使用.env文件管理敏感配置
2. 将.env加入.gitignore
3. 运行时通过环境变量注入
4. 提供.env.example作为配置模板

#### 8.2.3 团队协作问题

**问题**：前后端接口对接时规范不一致

解决方案：
1. 采用Knife4j生成API文档
2. 定义统一的响应格式（Result<T>）
3. 制定接口命名规范
4. 使用Postman/Insomnia共享接口集合

### 8.3 系统亮点与创新点

#### 8.3.1 技术创新

1. **AI自主判断检索（Tool Calling）**
   - 不同于传统RAG对所有问题都进行检索
   - 由LLM自主决定是否需要调用知识库检索
   - 对于简单问候直接回答，提升响应速度
   - 降低API调用成本

2. **智能文本切块（LangChain4j）**
   - 采用分层切块策略：段落 → 句子 → 字符
   - 保持语义完整性，避免句子中断
   - 根据文档类型自适应切块参数
   - Overlap机制保持上下文连贯

3. **流式响应设计**
   - SSE实现实时输出
   - 状态提示（检索中、生成中）
   - 知识来源实时展示
   - 用户体验接近ChatGPT

4. **多模型协同**
   - 阿里云Qwen3-Embedding进行向量化
   - DeepSeek进行对话生成
   - Milvus进行高效向量检索
   - 形成完整的RAG工作流

#### 8.3.2 工程亮点

1. **企业级架构设计**
   - Spring Boot 3.x + MyBatis-Plus分层架构
   - Spring Security + JWT认证
   - 完善的异常处理和日志记录
   - 统一响应格式和错误码

2. **容器化部署**
   - Docker多服务编排
   - 健康检查和自动重启
   - 配置外部化
   - 支持一键部署

3. **安全防护**
   - JWT无状态认证
   - XSS过滤
   - 接口限流
   - 提示词注入防护

### 8.4 不足之处与改进方向

#### 8.4.1 当前不足

1. **知识库管理**
   - 缺少知识库版本管理
   - 不支持增量更新
   - 缺少知识去重机制

2. **用户体验**
   - 暂无移动端适配
   - 缺少语音输入功能
   - 暂无问答反馈机制

3. **系统监控**
   - 缺少完善的监控面板
   - 日志分析功能不完善
   - 缺少性能调优工具

#### 8.4.2 改进方向

1. **功能增强**
   - 支持多轮对话记忆优化
   - 增加问答质量反馈机制
   - 支持多语言问答
   - 增加知识图谱辅助

2. **性能优化**
   - 引入Redis缓存热点知识
   - 优化向量检索参数
   - 实现问答结果缓存
   - 支持负载均衡部署

3. **运维增强**
   - 集成Prometheus/Grafana监控
   - 实现自动化CI/CD流程
   - 增加日志收集（ELK）
   - 完善备份恢复机制

4. **AI能力升级**
   - 支持多模态问答（图片）
   - 引入知识图谱增强检索
   - 实现主动学习机制
   - 支持模型微调

---

## 附录

### 附录A：项目目录结构

```
EchoCampus-Bot/
├── backend/                          # 后端项目
│   ├── src/main/java/com/echocampus/bot/
│   │   ├── config/                   # 配置类
│   │   ├── controller/               # 控制器
│   │   ├── service/                  # 服务层
│   │   ├── mapper/                   # 数据访问层
│   │   ├── entity/                   # 实体类
│   │   ├── dto/                      # 数据传输对象
│   │   ├── parser/                   # 文档解析器
│   │   ├── filter/                   # 过滤器
│   │   └── utils/                    # 工具类
│   ├── src/main/resources/
│   │   └── application.yml           # 配置文件
│   ├── pom.xml                       # Maven配置
│   └── Dockerfile                    # Docker构建文件
├── frontend/                         # 前端项目
│   ├── src/
│   │   ├── views/                    # 页面组件
│   │   ├── components/               # 通用组件
│   │   ├── stores/                   # 状态管理
│   │   ├── api/                      # API接口
│   │   └── utils/                    # 工具函数
│   ├── package.json                  # 依赖配置
│   └── vite.config.ts               # Vite配置
├── docs/                             # 文档目录
│   ├── 数据库设计.sql                # 数据库脚本
│   ├── 课程设计报告.md              # 本报告
│   └── ...                           # 其他文档
├── docker-compose.yml                # Docker编排
├── .env.example                      # 环境变量模板
└── README.md                         # 项目说明
```

### 附录B：核心配置参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| ai.embedding.model | text-embedding-v3 | Embedding模型 |
| ai.embedding.dimension | 1024 | 向量维度 |
| ai.llm.model | deepseek-chat | LLM模型 |
| ai.llm.max-tokens | 2000 | 最大生成Token |
| rag.top-k | 5 | 检索Top-K |
| rag.similarity-threshold | 0.6 | 相似度阈值 |
| document.chunking.max-size | 500 | 切块最大字符 |
| document.chunking.overlap-size | 50 | 切块重叠字符 |

### 附录C：参考资源

1. [Spring Boot官方文档](https://spring.io/projects/spring-boot)
2. [LangChain4j官方文档](https://docs.langchain4j.dev/)
3. [Milvus官方文档](https://milvus.io/docs)
4. [Vue.js 3官方文档](https://vuejs.org/)
5. [DeepSeek API文档](https://platform.deepseek.com/)
6. [阿里云百炼平台文档](https://bailian.console.aliyun.com/)

---

**报告完成日期**：2024年

**团队名称**：EchoTech Studio（"回应"工作室）

---
